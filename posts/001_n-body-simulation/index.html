<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Simulating the Cosmos - N Body Simulation | Squidev-Blog</title><meta name=keywords content="OpenGL,RealTime,Compute Shaders,Particle System,Post-Processing"><meta name=description content="Realtime Gravitational N-body simualtor with full OpenGL graphics pipeline accelerated with GLSL compute shader."><meta name=author content="Maythas Wangcharoenwong"><link rel=canonical href=https://squidev.github.io/posts/001_n-body-simulation/><link crossorigin=anonymous href=/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css integrity="sha256-NoGb6llgkNi0jPENmDE4KZYZeqfk/Ib3kvfAjJyk0js=" rel="preload stylesheet" as=style><link rel=icon href=https://squidev.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://squidev.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://squidev.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://squidev.github.io/apple-touch-icon.png><link rel=mask-icon href=https://squidev.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://squidev.github.io/posts/001_n-body-simulation/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://squidev.github.io/posts/001_n-body-simulation/"><meta property="og:site_name" content="Squidev-Blog"><meta property="og:title" content="Simulating the Cosmos - N Body Simulation"><meta property="og:description" content="Realtime Gravitational N-body simualtor with full OpenGL graphics pipeline accelerated with GLSL compute shader."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-02T22:11:31+07:00"><meta property="article:modified_time" content="2025-06-02T22:11:31+07:00"><meta property="article:tag" content="OpenGL"><meta property="article:tag" content="RealTime"><meta property="article:tag" content="Compute Shaders"><meta property="article:tag" content="Particle System"><meta property="article:tag" content="Post-Processing"><meta property="og:image" content="https://squidev.github.io/001_N-body-simulation/thumbnail.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://squidev.github.io/001_N-body-simulation/thumbnail.webp"><meta name=twitter:title content="Simulating the Cosmos - N Body Simulation"><meta name=twitter:description content="Realtime Gravitational N-body simualtor with full OpenGL graphics pipeline accelerated with GLSL compute shader."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://squidev.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Simulating the Cosmos - N Body Simulation","item":"https://squidev.github.io/posts/001_n-body-simulation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Simulating the Cosmos - N Body Simulation","name":"Simulating the Cosmos - N Body Simulation","description":"Realtime Gravitational N-body simualtor with full OpenGL graphics pipeline accelerated with GLSL compute shader.","keywords":["OpenGL","RealTime","Compute Shaders","Particle System","Post-Processing"],"articleBody":"A real-time visual simulation engine for simulating dynamical system of large cluster of celestial bodies using compute shaders. Provided with 2 mode controllable camera and GUI control panel.\nâ€»Youtube compression is not doing too well for this kind of video (preferably, try watch it from a smaller screen), if you really want to see it in full quality you can download the latest release\nFor the full source code and implementation: N-body-simulator Repository\nPreface This project is basically an educational project for me to learn how to properly use compute shaders, OpenGL, Post processing effects to make a visually stunning particle simulations. First, I must say that Physics is not my strong suit. With that given, the real aim of this project is to produce visually interesting simulation, not full physics accuracy (although I tried to be as accurate as possible). In a sense, the value in those of default test cases are extremely exaggerated so please be aware of this fact. As per the geometries of stellar clusters and how mass are mapped to colors, these are not fully accurate as well (To any physicist out there I am sorry (Â´ï¼›Ï‰ï¼›ï½€)). With that being said, the project provides multiple controllable variables for those who want to try setup the simulation for themselves as well as multiple default test cases to pick from so enjoy!! (*Â´Ï‰ï½€*)\nWhat is an N-body simulation The basic premises of an N-body simulation is, given an arbitrary number of particles n in a system, each and every particle in this system will interact with each other by some physical forces, which in our case is gravity. Generally this simulation is used as a tool to study dynamical system of particles, especially in fields such as astrophysics, cosmology, and molecular dynamics.\nProject Scope and Origin In this project, I have implemented a gravitational n-body variant of the simulation with the initial purpose to visually predict the motion of celestial bodies interacting with each other through gravity. The simulation is strictly gravitational using only Classical mechanics meaning there will be no collision and no insane objects like dark matter, dark energy, etcâ€¦\nIn one of the previous courses I took, the idea of 2 and 3 body system is briefly mentioned in the context of celestial mechanics. At the time, I was finding a project to do on OpenGL to learn about compute shaders, which led me to the idea of generalized n-body simulation. Initially I thought this project was not going to take this long but it got out of hand very quickly.\nImplementation Methodologies \u0026 Why Naive Approach Due to the fact that currently there exist no closed-form solution for calculating the position of every particle in a dynamic system where n\u003e2 (excluding some specific n = 3 ones). In our n-body system, we instead predict the position of each particle on the next time step based on their acceleration, velocity, and current position using something called a numerical integrator. However, in order to calculate the acceleration, we need to calculate the force of each particle which leads us to the topic of calculating force between each particle.\nfigure 0: Simulation GUI Calculating Gravitational Force Recall Newtonâ€™s universal law of gravitation. Let $r$ be the distance between the two particle and $m$ be the mass.\n$$F= \\frac{Gm_im_j}{r^2}$$\nTo calculate the force of one particle exerting on another ($m_j$ on $m_i$) $$F_{ij} = \\frac{Gm_im_j}{||r_i-r_j||^2}\\cdot -\\hat{r_{ij}}$$ $$ F_{ij} = \\frac{Gm_im_j}{||r_i - r_j||^2} \\cdot \\frac{-(r_i-r_j)}{||r_i-r_j||}$$ Using Newtonâ€™s second law of motion, we can derive the formula to calculate the acceleration of the particle using the accumulated force. $$F_{ij} = m_ia_{ij}$$ $$a_{ij} = \\frac{F_{ij}}{m_i}$$ Here we can now calculate the force acting on the current particle $i$ from other particles. Let there be a particle $i$ and let $K$ be a set of particles where $|K| = n-1, i \\notin K, \\forall j \\in K$. The acceleration of $i$ can now be calculate (accumulate) as follows. $$a_i = \\sum_{j \\ne i}^K a_{ij} \\text{\\quad;\\quad} a_im_i= \\sum_{j \\ne i}^K F_{ij}$$ $$a_i = \\frac{1}{m_i} \\sum_{j \\ne i}^k F_{ij} = \\frac{1}{m_i} \\sum_{j \\ne i}^k \\frac{Gm_im_j}{||r_i - r_j||^2} \\cdot -\\hat{r}_{ij}$$\n$$= G \\sum_{j \\ne i}^k \\frac{m_j}{||r_i - r_j||^2} \\cdot -\\hat{r}_{ij}$$\nThis can now be used to determine the acceleration of $\\forall i$ in the system. Using this formula, we can calculate naively calculate acceleration of the particles using the particle-particle method, or aka. calculate all pairs. This however would be very computationally expensive having a complexity of $O(n^2)$ making the system not so scalable. In favor of performance, we could choose to opt to use methods such as Barnes-Hut or FMM that utilizes data structures such as Oct-tree to decrease the time complexity to $O(nlog(n))$ and $O(n)$ in some special case respectively. However, since I am new to compute shaders, I chose to go with the naive $O(n^2)$ method first.\nNumerical Integrator Since we now know how to calculate the acceleration, we now need to calculate the position and velocity of the particle. As for the current, there are multiple numerical integrator that can be used to address issue by approximately the velocity based on the initial information given at each timestep and proceed them based on the size of each time step.\nThere are multiple integrator available for physics simulation:\nEuler Integrator Velocity-Verlet Integrator RK4(Runge-Kutta 4th order) Hermite etcâ€¦ In this simulator, Iâ€™ve implemented the following two integrators:\nSemi-Implicit Euler method The idea of Euler Method is the simplest and cheapest to compute but also the most inaccurate among all aforementioned integrators due to the linearly accumulating error and inability to conserve energy. The Semi-Implicit Euler Method however conserve energy better than the standard implementation just by simply updating the velocity before position at every step (explicit version does the opposite). $$v_{i+1} = v_i + a_i * \\Delta t $$ $$r_{i+1} = r_{i} + v_{i+1} * \\Delta t$$\nThis method is a 1st order meaning:\nLocal error: $O(\\Delta t^2)$ Global error: $O(\\Delta t$) Velocity-Verlet (KDK-Leapfrog) Also known as Kick-Drift-Kick Leapfrog. This method is almost as computationally cheap as Euler, however it is a 2nd order method that also conserves energy making it more accurate. To calculate the velocity and position, simply: $$v_{i+\\frac{1}{2}} = v_i + 0.5 * a_i * \\Delta t$$ $$r_{i+1} = r_i + v_{i+\\frac{1}{2}} * \\Delta t$$ $$a_{i+1} = \\text{acceleration using the new position } r_{i+1}$$ $$v_{i+1} = v_{i+\\frac{1}{2}} + 0.5 * a_i * \\Delta t$$\nThis method is a 2nd order method meaning\nLocal error: $O(\\Delta t^3)$ Global error: $O(\\Delta t^2)$ Engine Implementation This project features a custom-built engine that serves as the core driver for the simulation. It is designed to model and render gravitational interactions of large clusters of celestial bodies in real-time. The engine leverages GPU acceleration through custom-written compute shaders as well as implementing techniques such as instancing and post-processing to improve the visual fidelity. The following section will explain the engineâ€™s architecture and other important information.\nDependencies and Tools GLAD and GLFW for setting up and managing the OpenGL context GLM for mathematic operations. ImGui for the Graphical User Interface (GUI) Modules Brief Execution Flow The modules in this engine can be grouped into 5 parts as shown in the figure above.\nThe Graphics Components Modules Responsible for rendering frames to the window, managing mesh instancing, and applying post-processing effects such as bloom to enhance the visual fidelity of the simulation. The Physics Simulator Modules Responsible for handling the calculation of the dynamical system based on the chosen implementation and integrators. The User input and display information Modules Responsible for accepting user input from mouse control, keyboard input, and GUI toggles. Updates simulation and display statuses according to the user input and show the current state of the engine to the user through GUI. The simulation initializer Modules Responsible for taking in user input for initializing the particle data such as the geometry of the cluster, mass range, velocity range, number of particles for the simulator. The standalone program initializer Modules Initialize OpenGL context, creating windows, and initializing required components for sphere instancing. The Enums and Structs Modules Serves as data payload when transferring data between modules. The Graphics and Physics Modules are designed to be independent from each other ensuring ease of modification. The User input and Display information modules however are more tightly coupled with multiple other modules due to being the interface between the users and the engine. As a result, changes in other modules would often require update in this one.\nVery Brief Execution flow and Render Loop Brief Execution Flow Shader Pipeline and Post-Processing The post-processing effect implemented for this engine is, for the moment just bloom and some color correction features.\nBloom figure 2: Bloom off vs on The idea of bloom is mostly simple. We first render the scene onto 2 separated textures. For the first texture, we keep it as the original. For the second texture, we do 2 passes gaussian blur based on the intensity we want. Afterwards we combine the two texture and do some color correction and now we have a functioning bloom output that can be used to draw on a quad.\nPipeline Rendering Pipeline In this pipeline, we can split it into 2 main paths.\nBloom enabled: The main idea is basically we draw to a texture as an output, afterwards we use the texture rendered as quad for the following steps. â€» Do note that the $n/2$ in the image above is just a simplification\nglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, tex_id, 0); In this case we have to bind the render of the output to bloom shader with no Color correction (tone mapping and gamma correction) to a texture. After that we use one of the textures to do 2 passes blur for a number of times. After which we combines the output with the original texture then do the color correction and renders onto a quad. void calc_gaussian_kernel(){ for(int i = 0; i \u003c BLUR_RADIUS; i++){ weight[i] = exp(-0.5*(pow(i/sigma,2)))/ (sqrt(2*3.141592653589793)*sigma) ; } } void main(){ calc_gaussian_kernel(); vec2 tex_offset = 1.0 / textureSize(u_prev_texture, 0); //size of texel vec3 color = texture(u_prev_texture, tex_coord).rgb * weight[0]; if(is_horizontal){ for(int i = 1; i \u003c BLUR_RADIUS; i++){ color += texture(u_prev_texture, tex_coord + vec2(tex_offset.x * i,0)).rgb * weight[i]; color += texture(u_prev_texture, tex_coord - vec2(tex_offset.x * i,0)).rgb * weight[i]; } } else { // vertical for(int i = 1; i \u003c BLUR_RADIUS; i++){ color += texture(u_prev_texture, tex_coord + vec2(0, tex_offset.y * i)).rgb * weight[i]; color += texture(u_prev_texture, tex_coord - vec2(0, tex_offset.y * i)).rgb * weight[i]; } } FragColor = vec4(color,1.0f); } Important Notes\nâ€» Disable depth test before drawing to a quad (rectangle) Ensure you bind an RBO to the original scene FBO too otherwise we will some issue with depth Bloom disabled: Directly follow the path marked in green and render the scene out with color correction. HDR, Exposure Tone Mapping and Gamma Correction The color of the stars defined in HDR range\nvec3 yellow =vec3(5.0f, 2.0f, 0.24f); ... In this case we have to perform exposure tone-mapping to allow the brightness of scene to be displayed within range of a standard screen [0,1]\ncolor = vec3(1.0) - exp(-color * u_exposure); Afterwards, gamma correction is then applied to ensure the color to appear correctly on standard screen.\ncolor = pow(color, vec3(1.0/u_gamma)); Instancing Instancing is simple, in this case we just instance all the particles as a sphere using the VAO we bind earlier and draw elements using glDrawElementsInstanced, on the Shader side, we just simply scale the vertices of the sphere by its mass then offset them by the position stored in the SSBO.\nfigure 2: Instancing (+Wireframe) off vs on // CPU side if (!this-\u003euse_instancing) { this-\u003eshader_program-\u003eset_bool(\"use_instancing\", this-\u003euse_instancing); glDrawArrays(GL_POINTS, 0, this-\u003esimulator-\u003eget_n_particle()); } else { this-\u003eshader_program-\u003eset_bool(\"use_instancing\", !this-\u003euse_instancing); glDrawArrays(GL_POINTS, 0, this-\u003esimulator-\u003eget_n_particle()); this-\u003eshader_program-\u003eset_bool(\"use_instancing\", this-\u003euse_instancing); glDrawElementsInstanced(GL_TRIANGLES, 3 * this-\u003erender_components-\u003en_inds, GL_UNSIGNED_INT, (void *)0, this-\u003esimulator-\u003eget_n_particle()); } //light.vs layout (std430, binding = 0) buffer particle_position { vec4 position[]; }; //Check the full version on my repository ... ... ... if(!use_instancing){ new_pos = position[gl_VertexID]; star_mass = mass[gl_VertexID]; } else { if(use_mass_size){ mass_size += calculate_mass_scaler(gl_InstanceID); } new_pos = position[gl_InstanceID] + vec4(mass_size * v_pos,1.0); star_mass = mass[gl_InstanceID]; } Why draw twice when instancing (specifically for our case) Currently, we have no boundary set for our simulation meaning that once a particle moves away from the screen, it gets too tiny to get rendered onto the screen. With this issue in mind, we simply use glDrawArrays(GL_POINTS...) first to ensure that there will at least be something drawn to the screen at minimum size. Afterwards we draw the instanced version on top of the dot version. Doing this will ensure that for any area of the screen where the instanced particles are drawn, the point version will completely be blocked.\nOne draw call vs double draw call GPU optimization and performance Performance Due to time constraint, I have yet to make proper benchmarking scripts or setting up Nsight for performance profiling. The performance was recorded manually and averaged on the hardware this simulation was implemented in (RTX4070Ti GPU).\nThe FPS are written in format . These numbers should give a rough idea on how it should perform given this specific hardware.\n# Particles / Implementation (FPS) CPU Naive Particle-Particle GPU Naive Particle-Particle GPU Tiling Particle-Particle GPU Fine-Grain Particle-Particle n = 100 120 120 120 120 n = 1000 90-91 120 120 120 n = 10000 1 120 120 120 n = 30000 - 120 120 120 n = 50000 - 88 ~ 100 117 ~ 120 109 ~ 120 n = 65000 - 57 ~ 63 66 ~ 74 68 ~ 75 n = 100000 - 23 ~ 23 37 ~ 40 30 ~ 32 n = 150000 - 12 ~ 12 17 ~ 18 14 ~ 14 n = 200000 - 7 ~ 7 8 ~ 8 8 ~ 8 Naive GPU Implementation The naive implementation uses 1 workgroup per 64 particle. The idea is basically using velocity-verlet integrator to calculate the next step without further optimization.\nThis version does introduce some inaccuracies as well (I have yet to fix this). This is due to the fact that barrier only blocks the threads in the same workgroup, not globally, meaning that there can be some case of race conditions where position is used to calculate acceleration before some is updated.\nWork: $O(n^2)$ Span: $O(n)$ Available Parallelism: $O(n)$ uint id = gl_GlobalInvocationID.x; if (id \u003e= n_particle) return ; velocity[id] += acceleration[id] * timestep_size * 0.5; position[id] += velocity[id] * timestep_size; memoryBarrier(); barrier(); acceleration[id] = calculate_acceleration(id) * gravitational_constant; memoryBarrier(); barrier(); velocity[id] += acceleration[id] * timestep_size * 0.5; Tiling - Chunk Optimized GPU Implementation In this implementation, the idea of tiling in chunks into the shared memory has been introduced. Since fetching data repeatedly from global memory is an expensive operation. Having multiple threads in the same group collectively fetch a chunk of data into shared memory where the threads inside the same workgroup can access to calculate acceleration. This approach is likely a better approach since it reduces the amount of fetching needed to be done from global memory. This version is implemented in 2 passes.\nIn my case, a chunk-size of 512 and a workgroup of size x=256 seems to be the best performing settings.\nconst int CHUNK_SIZE = 512; shared vec4 chunk_position[CHUNK_SIZE]; shared float chunk_mass[CHUNK_SIZE]; void main(){.... uint particle_id = gl_GlobalInvocationID.x; uint local_id = gl_LocalInvocationID.x; Work: $O(n^2)$ Span: $O(n)$ Available Parallelism: $O(n)$ // Pre-load position of current particle if valid vec4 position_self = vec4(1.0f); if(particle_id \u003c n_particle){ position_self = position[particle_id]; } int max_load = CHUNK_SIZE; uint half_chunk = 256; uint fetch_id = 0; for (uint offset = 0; offset \u003c (n_particle + CHUNK_SIZE); offset+=CHUNK_SIZE){ // Load chunk chunk_mass[local_id*2] = mass[local_id*2 + offset]; chunk_position[local_id*2] = position[local_id*2 + offset]; chunk_mass[local_id*2+1] = mass[local_id*2 +1 + offset]; chunk_position[local_id*2+1] = position[local_id*2 + 1+ offset]; memoryBarrier(); barrier(); Here, each thread each load 2 pieces of data into shared memory per loop. From here calculation of acceleration is done as usual.\nFine-Grained GPU Implementation In this implementation, instead of using multiple particles per workgroup. I have decided to use 1 particle per work group. However, the amount work is equally distributed among threads.\nIn the first pass, we use the standard 256 particle per thread implementation to update the position and velocity.\nthis-\u003ecompute_shader_program.set_bool(\"first_pass\", true); glDispatchCompute(this-\u003en_work_groups, 1, 1); glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT); this-\u003ecompute_shader_program.set_bool(\"first_pass\", false); glDispatchCompute(this-\u003en_particle, 1, 1); Afterwards, for the second pass, we have shared variable setup for accumulation.\nshared vec4 local_acceleration_accumulator[256]; uint particle_id = gl_WorkGroupID.x; uint local_id = gl_LocalInvocationID.x; The acceleration calculation is then done by having each thread accumulate the acceleration based on their local id (workgroup ID ) then add this to the shared memory before proceeding to the next stage.\nfor (uint i = local_id; i \u003c uint(n_particle); i+= 256){ tmp_distance = position[particle_id] - position[i]; if(tmp_distance != vec4(0.0)){ tmp_direction = -normalize(tmp_distance); sq_distance = dot(tmp_distance,tmp_distance); local_acceleration_sum += (mass[i]/sqrt(sq_distance+sq_soften)) * tmp_direction; } } local_acceleration_accumulator[local_id] = local_acceleration_sum; barrier(); After accumulating all the acceleration locally, we then accumulate the acceleration using tree based reduction until acceleration at local_id 0 have the sum of all acceleration.\nfor (uint stride = 128; stride \u003e 0; stride \u003e\u003e=1) { if(local_id \u003c stride){ local_acceleration_accumulator[local_id] += local_acceleration_accumulator[local_id + stride]; } barrier(); } Afterwards we calculate the velocity as usual.\nWork: $O(n^2)$ Span: $O(n)$ Available Parallelism: $O(n)$ 2 Passes and Global Synchronization Since the order of computation of velocity-verlet is\nCalculate half velocity Calculate new position Calculate acceleration Calculate half velocity Between step 2 and 3, if some workgroup finishes faster than the other, we might have issue where the acceleration is calculated using the position other variables of the previous step creating minor accuracies that accumulate overtime.\nTo counter this issue, one way is to use 2 compute dispatch separated by global memory barrier.\nthis-\u003ecompute_shader_program.set_bool(\"first_pass\", true); glDispatchCompute(this-\u003en_work_groups, 1, 1); glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT); this-\u003ecompute_shader_program.set_bool(\"first_pass\", false); glDispatchCompute(this-\u003en_work_groups, 1, 1); something like this, to ensure that the value syncs before we update the next step.\nFuture Improvements Further optimization on the particle interaction calculations (use oct-tree, FMM, Barnes-Hutâ€¦) More effects? Save-Load system Known Issues If you set the velocity or mass to some crazy stuffs and you start to see some void ball in the middle of your screen, fear not for the stuffs is actually flying off the camera limitâ€¦ ðŸ˜‚ [Will need to set world boundary probably] The sphere is sampled usingÂ glm::sphericalRandÂ so there is a gaping hole and a line on some positionâ€¦ Particle-Particle NAIVE GPU have very minor inaccuracy issue due to being done in 1 pass References and Resources Here are list of resources I read while researching on how to build this simulator, you will probably find them useful if you want to dive deeper into this subject!\nhttps://learnopengl.com/ https://www.youtube.com/@OnurMutluLectures https://en.wikipedia.org/wiki/n-bodyÂ problem. (n.d.). https://en.wikipedia.org/wiki/Leapfrog_integration Dehnen, W., \u0026 Read, J. (2011). N-body simulations of gravitational dynamics. arxiv:1105.1082v1. Brandt, A. (2022, 03). On distributed gravitational n-body simulations, arxiv:2203.08966.Â https://arxiv.org/pdf/2203.08966 Computation and astrophysics of the n-body problem. (n.d.). Graps, A. (1996). N-body / particle simulation methods.Â https://www.cs.cmu.edu/afs/cs/academic/class/15850c-s96/www/nbody.html https://www.algorithm-archive.org/contents/verlet_integration/verlet_integration.html https://developer.nvidia.com/gpugems/gpugems/part-vi-beyond-triangles/chapter-37-toolkit-computation-gpus https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation/chapter-31-fast-n-body-simulation-cuda ","wordCount":"3149","inLanguage":"en","image":"https://squidev.github.io/001_N-body-simulation/thumbnail.webp","datePublished":"2025-06-02T22:11:31+07:00","dateModified":"2025-06-02T22:11:31+07:00","author":[{"@type":"Person","name":"Maythas Wangcharoenwong"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://squidev.github.io/posts/001_n-body-simulation/"},"publisher":{"@type":"Organization","name":"Squidev-Blog","logo":{"@type":"ImageObject","url":"https://squidev.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://squidev.github.io/ accesskey=h title="Squidev-Blog (Alt + H)">Squidev-Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://squidev.github.io/ja/ title=Japanese aria-label=æ—¥æœ¬èªž>æ—¥æœ¬èªž</a></li></ul></div></div><ul id=menu><li><a href=https://squidev.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://squidev.github.io/archives/ title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://squidev.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://squidev.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Simulating the Cosmos - N Body Simulation</h1><div class=post-description>Realtime Gravitational N-body simualtor with full OpenGL graphics pipeline accelerated with GLSL compute shader.</div><div class=post-meta><span title='2025-06-02 22:11:31 +0700 +07'>June 2, 2025</span>&nbsp;Â·&nbsp;15 min&nbsp;Â·&nbsp;3149 words&nbsp;Â·&nbsp;Maythas Wangcharoenwong</div></header><figure class=entry-cover><a href=https://squidev.github.io/001_N-body-simulation/thumbnail.webp target=_blank rel="noopener noreferrer"><img loading=eager src=https://squidev.github.io/001_N-body-simulation/thumbnail.webp alt="N-body simulation default test 30"></a></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#preface>Preface</a></li><li><a href=#what-is-an-n-body-simulation>What is an N-body simulation</a></li><li><a href=#project-scope-and-origin>Project Scope and Origin</a></li><li><a href=#implementation-methodologies--why-naive-approach>Implementation Methodologies & Why Naive Approach</a><ul><li><a href=#calculating-gravitational-force>Calculating Gravitational Force</a></li><li><a href=#numerical-integrator>Numerical Integrator</a></li></ul></li><li><a href=#engine-implementation>Engine Implementation</a><ul><li><a href=#dependencies-and-tools>Dependencies and Tools</a></li><li><a href=#modules>Modules</a></li><li><a href=#very-brief-execution-flow-and-render-loop>Very Brief Execution flow and Render Loop</a></li></ul></li><li><a href=#shader-pipeline-and-post-processing>Shader Pipeline and Post-Processing</a><ul><li><a href=#bloom>Bloom</a></li><li><a href=#pipeline>Pipeline</a></li><li><a href=#hdr-exposure-tone-mapping-and-gamma-correction>HDR, Exposure Tone Mapping and Gamma Correction</a></li></ul></li><li><a href=#instancing>Instancing</a><ul><li><a href=#why-draw-twice-when-instancing-specifically-for-our-case>Why draw twice when instancing (specifically for our case)</a></li></ul></li><li><a href=#gpu-optimization-and-performance>GPU optimization and performance</a><ul><li><a href=#performance>Performance</a></li><li><a href=#naive-gpu-implementation>Naive GPU Implementation</a></li><li><a href=#tiling---chunk-optimized-gpu-implementation>Tiling - Chunk Optimized GPU Implementation</a></li><li><a href=#fine-grained-gpu-implementation>Fine-Grained GPU Implementation</a></li><li><a href=#2-passes-and-global-synchronization>2 Passes and Global Synchronization</a></li></ul></li><li><a href=#future-improvements>Future Improvements</a><ul><li><a href=#known-issues>Known Issues</a></li></ul></li><li><a href=#references-and-resources>References and Resources</a></li></ul></nav></div></details></div><div class=post-content><p>A real-time visual simulation engine for simulating dynamical system of large cluster of celestial bodies using compute shaders. Provided with 2 mode controllable camera and GUI control panel.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/zHSgu5Cd_NQ?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><p>â€»Youtube compression is not doing too well for this kind of video (preferably, try watch it from a smaller screen), if you really want to see it in full quality you can download the latest release</p><p><strong>For the full source code and implementation: <a href=https://github.com/maythaswang/N-body-simulator>N-body-simulator Repository</a></strong></p><h2 id=preface>Preface<a hidden class=anchor aria-hidden=true href=#preface>#</a></h2><p>This project is basically an educational project for me to learn how to properly use compute shaders, OpenGL, Post processing effects to make a visually stunning particle simulations. First, I must say that Physics is not my strong suit. With that given, the real aim of this project is to produce visually interesting simulation, not full physics accuracy (although I tried to be as accurate as possible). In a sense, the value in those of default test cases are extremely exaggerated so please be aware of this fact. As per the geometries of stellar clusters and how mass are mapped to colors, these are not fully accurate as well (To any physicist out there I am sorry (Â´ï¼›Ï‰ï¼›ï½€)). With that being said, the project provides multiple controllable variables for those who want to try setup the simulation for themselves as well as multiple default test cases to pick from so enjoy!! (*Â´Ï‰ï½€*)</p><h2 id=what-is-an-n-body-simulation>What is an N-body simulation<a hidden class=anchor aria-hidden=true href=#what-is-an-n-body-simulation>#</a></h2><p>The basic premises of an N-body simulation is, given an arbitrary number of particles <em>n</em> in a system, each and every particle in this system will interact with each other by some physical forces, which in our case is gravity. Generally this simulation is used as a tool to study dynamical system of particles, especially in fields such as astrophysics, cosmology, and molecular dynamics.</p><h2 id=project-scope-and-origin>Project Scope and Origin<a hidden class=anchor aria-hidden=true href=#project-scope-and-origin>#</a></h2><p>In this project, I have implemented a gravitational n-body variant of the simulation with the initial purpose to visually predict the motion of celestial bodies interacting with each other through gravity. The simulation is strictly gravitational using only Classical mechanics meaning there will be no collision and no insane objects like dark matter, dark energy, etc&mldr;</p><p>In one of the previous courses I took, the idea of 2 and 3 body system is briefly mentioned in the context of celestial mechanics. At the time, I was finding a project to do on OpenGL to learn about compute shaders, which led me to the idea of generalized n-body simulation. Initially I thought this project was not going to take this long but it got out of hand very quickly.</p><h2 id=implementation-methodologies--why-naive-approach>Implementation Methodologies & Why Naive Approach<a hidden class=anchor aria-hidden=true href=#implementation-methodologies--why-naive-approach>#</a></h2><p>Due to the fact that currently there exist no closed-form solution for calculating the position of every particle in a dynamic system where n>2 (excluding some specific n = 3 ones). In our n-body system, we instead predict the position of each particle on the next time step based on their acceleration, velocity, and current position using something called a numerical integrator. However, in order to calculate the acceleration, we need to calculate the force of each particle which leads us to the topic of calculating force between each particle.</p><p align=center><img src=/001_N-body-simulation/GUI_example.webp loading=lazy alt=GUI_example><br><i>figure 0: Simulation GUI</i></p><br><h3 id=calculating-gravitational-force>Calculating Gravitational Force<a hidden class=anchor aria-hidden=true href=#calculating-gravitational-force>#</a></h3><p>Recall Newton&rsquo;s universal law of gravitation. Let $r$ be the distance between the two particle and $m$ be the mass.</p><p>$$F= \frac{Gm_im_j}{r^2}$$</p><p>To calculate the force of one particle exerting on another ($m_j$ on $m_i$)
$$F_{ij} = \frac{Gm_im_j}{||r_i-r_j||^2}\cdot -\hat{r_{ij}}$$
$$ F_{ij} = \frac{Gm_im_j}{||r_i - r_j||^2} \cdot \frac{-(r_i-r_j)}{||r_i-r_j||}$$
Using Newton&rsquo;s second law of motion, we can derive the formula to calculate the acceleration of the particle using the accumulated force.
$$F_{ij} = m_ia_{ij}$$
$$a_{ij} = \frac{F_{ij}}{m_i}$$
Here we can now calculate the force acting on the current particle $i$ from other particles.
Let there be a particle $i$ and let $K$ be a set of particles where $|K| = n-1, i \notin K, \forall j \in K$. The acceleration of $i$ can now be calculate (accumulate) as follows.
$$a_i = \sum_{j \ne i}^K a_{ij} \text{\quad;\quad} a_im_i= \sum_{j \ne i}^K F_{ij}$$
$$a_i = \frac{1}{m_i} \sum_{j \ne i}^k F_{ij} = \frac{1}{m_i} \sum_{j \ne i}^k \frac{Gm_im_j}{||r_i - r_j||^2} \cdot -\hat{r}_{ij}$$</p><p>$$= G \sum_{j \ne i}^k \frac{m_j}{||r_i - r_j||^2} \cdot -\hat{r}_{ij}$$</p><p>This can now be used to determine the acceleration of $\forall i$ in the system.
Using this formula, we can calculate naively calculate acceleration of the particles using the particle-particle method, or aka. calculate all pairs. This however would be very computationally expensive having a complexity of $O(n^2)$ making the system not so scalable. In favor of performance, we could choose to opt to use methods such as Barnes-Hut or FMM that utilizes data structures such as Oct-tree to decrease the time complexity to $O(nlog(n))$ and $O(n)$ in some special case respectively. However, since I am new to compute shaders, I chose to go with the naive $O(n^2)$ method first.</p><h3 id=numerical-integrator>Numerical Integrator<a hidden class=anchor aria-hidden=true href=#numerical-integrator>#</a></h3><p>Since we now know how to calculate the acceleration, we now need to calculate the position and velocity of the particle. As for the current, there are multiple numerical integrator that can be used to address issue by approximately the velocity based on the initial information given at each timestep and proceed them based on the size of each time step.</p><p>There are multiple integrator available for physics simulation:</p><ul><li>Euler Integrator</li><li>Velocity-Verlet Integrator</li><li>RK4(Runge-Kutta 4th order)</li><li>Hermite</li><li>etc&mldr;</li></ul><p>In this simulator, I&rsquo;ve implemented the following two integrators:</p><h4 id=semi-implicit-euler-method>Semi-Implicit Euler method<a hidden class=anchor aria-hidden=true href=#semi-implicit-euler-method>#</a></h4><p>The idea of Euler Method is the simplest and cheapest to compute but also the most inaccurate among all aforementioned integrators due to the linearly accumulating error and inability to conserve energy. The Semi-Implicit Euler Method however conserve energy better than the standard implementation just by simply updating the velocity before position at every step (explicit version does the opposite).
$$v_{i+1} = v_i + a_i * \Delta t $$
$$r_{i+1} = r_{i} + v_{i+1} * \Delta t$$</p><p>This method is a 1st order meaning:</p><ul><li>Local error: $O(\Delta t^2)$</li><li>Global error: $O(\Delta t$)</li></ul><h4 id=velocity-verlet-kdk-leapfrog>Velocity-Verlet (KDK-Leapfrog)<a hidden class=anchor aria-hidden=true href=#velocity-verlet-kdk-leapfrog>#</a></h4><p>Also known as Kick-Drift-Kick Leapfrog. This method is almost as computationally cheap as Euler, however it is a 2nd order method that also conserves energy making it more accurate. To calculate the velocity and position, simply:
$$v_{i+\frac{1}{2}} = v_i + 0.5 * a_i * \Delta t$$
$$r_{i+1} = r_i + v_{i+\frac{1}{2}} * \Delta t$$
$$a_{i+1} = \text{acceleration using the new position } r_{i+1}$$
$$v_{i+1} = v_{i+\frac{1}{2}} + 0.5 * a_i * \Delta t$$</p><p>This method is a 2nd order method meaning</p><ul><li>Local error: $O(\Delta t^3)$</li><li>Global error: $O(\Delta t^2)$</li></ul><h2 id=engine-implementation>Engine Implementation<a hidden class=anchor aria-hidden=true href=#engine-implementation>#</a></h2><p>This project features a custom-built engine that serves as the core driver for the simulation. It is designed to model and render gravitational interactions of large clusters of celestial bodies in real-time. The engine leverages GPU acceleration through custom-written compute shaders as well as implementing techniques such as instancing and post-processing to improve the visual fidelity. The following section will explain the engine&rsquo;s architecture and other important information.</p><h3 id=dependencies-and-tools>Dependencies and Tools<a hidden class=anchor aria-hidden=true href=#dependencies-and-tools>#</a></h3><ul><li><strong>GLAD</strong> and <strong>GLFW</strong> for setting up and managing the OpenGL context</li><li><strong>GLM</strong> for mathematic operations.</li><li><strong>ImGui</strong> for the Graphical User Interface (GUI)</li></ul><h3 id=modules>Modules<a hidden class=anchor aria-hidden=true href=#modules>#</a></h3><p align=center><img src=/001_N-body-simulation/ARCH.webp loading=lazy alt=ARCH><br>Brief Execution Flow</p><br><p>The modules in this engine can be grouped into 5 parts as shown in the figure above.</p><ol><li>The Graphics Components Modules<ul><li>Responsible for rendering frames to the window, managing mesh instancing, and applying post-processing effects such as bloom to enhance the visual fidelity of the simulation.</li></ul></li><li>The Physics Simulator Modules<ul><li>Responsible for handling the calculation of the dynamical system based on the chosen implementation and integrators.</li></ul></li><li>The User input and display information Modules<ul><li>Responsible for accepting user input from mouse control, keyboard input, and GUI toggles.</li><li>Updates simulation and display statuses according to the user input and show the current state of the engine to the user through GUI.</li></ul></li><li>The simulation initializer Modules<ul><li>Responsible for taking in user input for initializing the particle data such as the geometry of the cluster, mass range, velocity range, number of particles for the simulator.</li></ul></li><li>The standalone program initializer Modules<ul><li>Initialize OpenGL context, creating windows, and initializing required components for sphere instancing.</li></ul></li><li>The Enums and Structs Modules<ul><li>Serves as data payload when transferring data between modules.</li></ul></li></ol><p>The Graphics and Physics Modules are designed to be independent from each other ensuring ease of modification. The User input and Display information modules however are more tightly coupled with multiple other modules due to being the interface between the users and the engine. As a result, changes in other modules would often require update in this one.</p><h3 id=very-brief-execution-flow-and-render-loop>Very Brief Execution flow and Render Loop<a hidden class=anchor aria-hidden=true href=#very-brief-execution-flow-and-render-loop>#</a></h3><p align=center><img src=/001_N-body-simulation/program_flow.webp loading=lazy alt=program_flow><br>Brief Execution Flow</p><br><h2 id=shader-pipeline-and-post-processing>Shader Pipeline and Post-Processing<a hidden class=anchor aria-hidden=true href=#shader-pipeline-and-post-processing>#</a></h2><p>The post-processing effect implemented for this engine is, for the moment just bloom and some color correction features.</p><h3 id=bloom>Bloom<a hidden class=anchor aria-hidden=true href=#bloom>#</a></h3><p align=center><img src=/001_N-body-simulation/bloom_off_vs_on.webp loading=lazy alt=bloom_off_vs_on><br><i>figure 2: Bloom off vs on</i></p><br><p>The idea of bloom is mostly simple. We first render the scene onto 2 separated textures. For the first texture, we keep it as the original. For the second texture, we do 2 passes gaussian blur based on the intensity we want. Afterwards we combine the two texture and do some color correction and now we have a functioning bloom output that can be used to draw on a quad.</p><h3 id=pipeline>Pipeline<a hidden class=anchor aria-hidden=true href=#pipeline>#</a></h3><p align=center><img src=/001_N-body-simulation/rendering_pipeline.webp loading=lazy alt=rendering_pipeline><br>Rendering Pipeline</p><br><p>In this pipeline, we can split it into 2 main paths.</p><ol><li><strong>Bloom enabled:</strong></li></ol><ul><li>The main idea is basically we draw to a texture as an output, afterwards we use the texture rendered as quad for the following steps.</li></ul><p>â€» Do note that the $n/2$ in the image above is just a simplification</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>glFramebufferTexture2D</span><span class=p>(</span><span class=n>GL_FRAMEBUFFER</span><span class=p>,</span> <span class=n>GL_COLOR_ATTACHMENT0</span><span class=p>,</span> <span class=n>GL_TEXTURE_2D</span><span class=p>,</span> <span class=n>tex_id</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>In this case we have to bind the render of the output to bloom shader with no Color correction (tone mapping and gamma correction) to a texture.</li><li>After that we use one of the textures to do 2 passes blur for a number of times.</li><li>After which we combines the output with the original texture then do the color correction and renders onto a quad.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>calc_gaussian_kernel</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>BLUR_RADIUS</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>weight</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>exp</span><span class=p>(</span><span class=o>-</span><span class=mf>0.5</span><span class=o>*</span><span class=p>(</span><span class=n>pow</span><span class=p>(</span><span class=n>i</span><span class=o>/</span><span class=n>sigma</span><span class=p>,</span><span class=mi>2</span><span class=p>)))</span><span class=o>/</span> <span class=p>(</span><span class=n>sqrt</span><span class=p>(</span><span class=mi>2</span><span class=o>*</span><span class=mf>3.141592653589793</span><span class=p>)</span><span class=o>*</span><span class=n>sigma</span><span class=p>)</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=n>calc_gaussian_kernel</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>vec2</span> <span class=n>tex_offset</span> <span class=o>=</span> <span class=mf>1.0</span> <span class=o>/</span> <span class=n>textureSize</span><span class=p>(</span><span class=n>u_prev_texture</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>//size of texel
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>vec3</span> <span class=n>color</span> <span class=o>=</span> <span class=n>texture</span><span class=p>(</span><span class=n>u_prev_texture</span><span class=p>,</span> <span class=n>tex_coord</span><span class=p>).</span><span class=n>rgb</span> <span class=o>*</span> <span class=n>weight</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>is_horizontal</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>BLUR_RADIUS</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>color</span> <span class=o>+=</span> <span class=n>texture</span><span class=p>(</span><span class=n>u_prev_texture</span><span class=p>,</span> <span class=n>tex_coord</span> <span class=o>+</span> <span class=n>vec2</span><span class=p>(</span><span class=n>tex_offset</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>i</span><span class=p>,</span><span class=mi>0</span><span class=p>)).</span><span class=n>rgb</span> <span class=o>*</span> <span class=n>weight</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>color</span> <span class=o>+=</span> <span class=n>texture</span><span class=p>(</span><span class=n>u_prev_texture</span><span class=p>,</span> <span class=n>tex_coord</span> <span class=o>-</span> <span class=n>vec2</span><span class=p>(</span><span class=n>tex_offset</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>i</span><span class=p>,</span><span class=mi>0</span><span class=p>)).</span><span class=n>rgb</span> <span class=o>*</span> <span class=n>weight</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span> <span class=c1>// vertical
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>BLUR_RADIUS</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>color</span> <span class=o>+=</span> <span class=n>texture</span><span class=p>(</span><span class=n>u_prev_texture</span><span class=p>,</span> <span class=n>tex_coord</span> <span class=o>+</span> <span class=n>vec2</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>tex_offset</span><span class=p>.</span><span class=n>y</span> <span class=o>*</span> <span class=n>i</span><span class=p>)).</span><span class=n>rgb</span> <span class=o>*</span> <span class=n>weight</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>color</span> <span class=o>+=</span> <span class=n>texture</span><span class=p>(</span><span class=n>u_prev_texture</span><span class=p>,</span> <span class=n>tex_coord</span> <span class=o>-</span> <span class=n>vec2</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>tex_offset</span><span class=p>.</span><span class=n>y</span> <span class=o>*</span> <span class=n>i</span><span class=p>)).</span><span class=n>rgb</span> <span class=o>*</span> <span class=n>weight</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>FragColor</span> <span class=o>=</span> <span class=n>vec4</span><span class=p>(</span><span class=n>color</span><span class=p>,</span><span class=mf>1.0f</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>Important Notes</strong></p><ul><li>â€» Disable depth test before drawing to a quad (rectangle)</li><li>Ensure you bind an RBO to the original scene FBO too otherwise we will some issue with depth</li></ul><ol><li><strong>Bloom disabled:</strong></li></ol><ul><li>Directly follow the path marked in green and render the scene out with color correction.</li></ul><h3 id=hdr-exposure-tone-mapping-and-gamma-correction>HDR, Exposure Tone Mapping and Gamma Correction<a hidden class=anchor aria-hidden=true href=#hdr-exposure-tone-mapping-and-gamma-correction>#</a></h3><p>The color of the stars defined in HDR range</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>    <span class=n>vec3</span> <span class=n>yellow</span> <span class=o>=</span><span class=n>vec3</span><span class=p>(</span><span class=mf>5.0f</span><span class=p>,</span> <span class=mf>2.0f</span><span class=p>,</span> <span class=mf>0.24f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span></code></pre></div><p>In this case we have to perform exposure tone-mapping to allow the brightness of scene to be displayed within range of a standard screen [0,1]</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>	<span class=n>color</span> <span class=o>=</span> <span class=n>vec3</span><span class=p>(</span><span class=mf>1.0</span><span class=p>)</span> <span class=o>-</span> <span class=n>exp</span><span class=p>(</span><span class=o>-</span><span class=n>color</span> <span class=o>*</span> <span class=n>u_exposure</span><span class=p>);</span>
</span></span></code></pre></div><p>Afterwards, gamma correction is then applied to ensure the color to appear correctly on standard screen.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>    <span class=n>color</span> <span class=o>=</span> <span class=n>pow</span><span class=p>(</span><span class=n>color</span><span class=p>,</span> <span class=n>vec3</span><span class=p>(</span><span class=mf>1.0</span><span class=o>/</span><span class=n>u_gamma</span><span class=p>));</span>
</span></span></code></pre></div><h2 id=instancing>Instancing<a hidden class=anchor aria-hidden=true href=#instancing>#</a></h2><p>Instancing is simple, in this case we just instance all the particles as a sphere using the VAO we bind earlier and draw elements using <code>glDrawElementsInstanced</code>, on the Shader side, we just simply scale the vertices of the sphere by its mass then offset them by the position stored in the SSBO.</p><p align=center><img src=/001_N-body-simulation/instancing_off_vs_on.webp loading=lazy alt=instancing_off_vs_on><br><i>figure 2: Instancing (+Wireframe) off vs on</i></p><br><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// CPU side
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=k>this</span><span class=o>-&gt;</span><span class=n>use_instancing</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>-&gt;</span><span class=n>shader_program</span><span class=o>-&gt;</span><span class=n>set_bool</span><span class=p>(</span><span class=s>&#34;use_instancing&#34;</span><span class=p>,</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>use_instancing</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>glDrawArrays</span><span class=p>(</span><span class=n>GL_POINTS</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>simulator</span><span class=o>-&gt;</span><span class=n>get_n_particle</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>-&gt;</span><span class=n>shader_program</span><span class=o>-&gt;</span><span class=n>set_bool</span><span class=p>(</span><span class=s>&#34;use_instancing&#34;</span><span class=p>,</span> <span class=o>!</span><span class=k>this</span><span class=o>-&gt;</span><span class=n>use_instancing</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>glDrawArrays</span><span class=p>(</span><span class=n>GL_POINTS</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>simulator</span><span class=o>-&gt;</span><span class=n>get_n_particle</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>-&gt;</span><span class=n>shader_program</span><span class=o>-&gt;</span><span class=n>set_bool</span><span class=p>(</span><span class=s>&#34;use_instancing&#34;</span><span class=p>,</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>use_instancing</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>glDrawElementsInstanced</span><span class=p>(</span><span class=n>GL_TRIANGLES</span><span class=p>,</span> <span class=mi>3</span> <span class=o>*</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>render_components</span><span class=o>-&gt;</span><span class=n>n_inds</span><span class=p>,</span> <span class=n>GL_UNSIGNED_INT</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=mi>0</span><span class=p>,</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>simulator</span><span class=o>-&gt;</span><span class=n>get_n_particle</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//light.vs
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>layout</span> <span class=p>(</span><span class=n>std430</span><span class=p>,</span> <span class=n>binding</span> <span class=o>=</span> <span class=mi>0</span><span class=p>)</span> <span class=n>buffer</span> <span class=n>particle_position</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>	<span class=n>vec4</span> <span class=n>position</span><span class=p>[];</span> 
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>//Check the full version on my repository
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>...</span> 
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>use_instancing</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=n>new_pos</span> <span class=o>=</span> <span class=n>position</span><span class=p>[</span><span class=n>gl_VertexID</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>star_mass</span> <span class=o>=</span> <span class=n>mass</span><span class=p>[</span><span class=n>gl_VertexID</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>use_mass_size</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=n>mass_size</span> <span class=o>+=</span> <span class=n>calculate_mass_scaler</span><span class=p>(</span><span class=n>gl_InstanceID</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>new_pos</span> <span class=o>=</span> <span class=n>position</span><span class=p>[</span><span class=n>gl_InstanceID</span><span class=p>]</span> <span class=o>+</span> <span class=n>vec4</span><span class=p>(</span><span class=n>mass_size</span> <span class=o>*</span> <span class=n>v_pos</span><span class=p>,</span><span class=mf>1.0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=n>star_mass</span> <span class=o>=</span> <span class=n>mass</span><span class=p>[</span><span class=n>gl_InstanceID</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></div><h3 id=why-draw-twice-when-instancing-specifically-for-our-case>Why draw twice when instancing (specifically for our case)<a hidden class=anchor aria-hidden=true href=#why-draw-twice-when-instancing-specifically-for-our-case>#</a></h3><p>Currently, we have no boundary set for our simulation meaning that once a particle moves away from the screen, it gets too tiny to get rendered onto the screen. With this issue in mind, we simply use <code>glDrawArrays(GL_POINTS...)</code> first to ensure that there will at least be something drawn to the screen at minimum size. Afterwards we draw the instanced version on top of the dot version. Doing this will ensure that for any area of the screen where the instanced particles are drawn, the point version will completely be blocked.</p><p align=center><img src=/001_N-body-simulation/1vsdouble_draw.webp loading=lazy alt=1vsdouble_draw><br>One draw call vs double draw call</p><br><h2 id=gpu-optimization-and-performance>GPU optimization and performance<a hidden class=anchor aria-hidden=true href=#gpu-optimization-and-performance>#</a></h2><h3 id=performance>Performance<a hidden class=anchor aria-hidden=true href=#performance>#</a></h3><p>Due to time constraint, I have yet to make proper benchmarking scripts or setting up Nsight for performance profiling. The performance was recorded manually and averaged on the hardware this simulation was implemented in (RTX4070Ti GPU).</p><p>The FPS are written in format &lt;Effects ON - Effects OFF>. These numbers should give a rough idea on how it should perform given this specific hardware.</p><table><thead><tr><th># Particles / Implementation (FPS)</th><th>CPU Naive Particle-Particle</th><th>GPU Naive Particle-Particle</th><th>GPU Tiling Particle-Particle</th><th>GPU Fine-Grain Particle-Particle</th></tr></thead><tbody><tr><td>n = 100</td><td>120</td><td>120</td><td>120</td><td>120</td></tr><tr><td>n = 1000</td><td>90-91</td><td>120</td><td>120</td><td>120</td></tr><tr><td>n = 10000</td><td>1</td><td>120</td><td>120</td><td>120</td></tr><tr><td>n = 30000</td><td>-</td><td>120</td><td>120</td><td>120</td></tr><tr><td>n = 50000</td><td>-</td><td>88 ~ 100</td><td>117 ~ 120</td><td>109 ~ 120</td></tr><tr><td>n = 65000</td><td>-</td><td>57 ~ 63</td><td>66 ~ 74</td><td>68 ~ 75</td></tr><tr><td>n = 100000</td><td>-</td><td>23 ~ 23</td><td>37 ~ 40</td><td>30 ~ 32</td></tr><tr><td>n = 150000</td><td>-</td><td>12 ~ 12</td><td>17 ~ 18</td><td>14 ~ 14</td></tr><tr><td>n = 200000</td><td>-</td><td>7 ~ 7</td><td>8 ~ 8</td><td>8 ~ 8</td></tr></tbody></table><h3 id=naive-gpu-implementation>Naive GPU Implementation<a hidden class=anchor aria-hidden=true href=#naive-gpu-implementation>#</a></h3><p>The naive implementation uses 1 workgroup per 64 particle. The idea is basically using velocity-verlet integrator to calculate the next step without further optimization.</p><p>This version does introduce some inaccuracies as well (I have yet to fix this). This is due to the fact that barrier only blocks the threads in the same workgroup, not globally, meaning that there can be some case of race conditions where position is used to calculate acceleration before some is updated.</p><ul><li>Work: $O(n^2)$</li><li>Span: $O(n)$</li><li>Available Parallelism: $O(n)$</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>	<span class=n>uint</span> <span class=n>id</span> <span class=o>=</span> <span class=n>gl_GlobalInvocationID</span><span class=p>.</span><span class=n>x</span><span class=p>;</span>   
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>id</span> <span class=o>&gt;=</span> <span class=n>n_particle</span><span class=p>)</span> <span class=k>return</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>velocity</span><span class=p>[</span><span class=n>id</span><span class=p>]</span> <span class=o>+=</span> <span class=n>acceleration</span><span class=p>[</span><span class=n>id</span><span class=p>]</span> <span class=o>*</span> <span class=n>timestep_size</span> <span class=o>*</span> <span class=mf>0.5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>position</span><span class=p>[</span><span class=n>id</span><span class=p>]</span> <span class=o>+=</span> <span class=n>velocity</span><span class=p>[</span><span class=n>id</span><span class=p>]</span> <span class=o>*</span> <span class=n>timestep_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>memoryBarrier</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>barrier</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>acceleration</span><span class=p>[</span><span class=n>id</span><span class=p>]</span> <span class=o>=</span> <span class=n>calculate_acceleration</span><span class=p>(</span><span class=n>id</span><span class=p>)</span> <span class=o>*</span> <span class=n>gravitational_constant</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>memoryBarrier</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>barrier</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>velocity</span><span class=p>[</span><span class=n>id</span><span class=p>]</span> <span class=o>+=</span> <span class=n>acceleration</span><span class=p>[</span><span class=n>id</span><span class=p>]</span> <span class=o>*</span> <span class=n>timestep_size</span> <span class=o>*</span> <span class=mf>0.5</span><span class=p>;</span> 
</span></span></code></pre></div><h3 id=tiling---chunk-optimized-gpu-implementation>Tiling - Chunk Optimized GPU Implementation<a hidden class=anchor aria-hidden=true href=#tiling---chunk-optimized-gpu-implementation>#</a></h3><p>In this implementation, the idea of tiling in chunks into the shared memory has been introduced. Since fetching data repeatedly from global memory is an expensive operation. Having multiple threads in the same group collectively fetch a chunk of data into shared memory where the threads inside the same workgroup can access to calculate acceleration. This approach is likely a better approach since it reduces the amount of fetching needed to be done from global memory. This version is implemented in 2 passes.</p><p>In my case, a chunk-size of 512 and a workgroup of size x=256 seems to be the best performing settings.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>CHUNK_SIZE</span> <span class=o>=</span> <span class=mi>512</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>shared</span> <span class=n>vec4</span> <span class=n>chunk_position</span><span class=p>[</span><span class=n>CHUNK_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>shared</span> <span class=kt>float</span> <span class=n>chunk_mass</span><span class=p>[</span><span class=n>CHUNK_SIZE</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>main</span><span class=p>(){....</span>
</span></span><span class=line><span class=cl><span class=n>uint</span> <span class=n>particle_id</span> <span class=o>=</span> <span class=n>gl_GlobalInvocationID</span><span class=p>.</span><span class=n>x</span><span class=p>;</span>   
</span></span><span class=line><span class=cl><span class=n>uint</span> <span class=n>local_id</span> <span class=o>=</span> <span class=n>gl_LocalInvocationID</span><span class=p>.</span><span class=n>x</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>Work: $O(n^2)$</li><li>Span: $O(n)$</li><li>Available Parallelism: $O(n)$</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Pre-load position of current particle if valid
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>vec4</span> <span class=n>position_self</span> <span class=o>=</span> <span class=n>vec4</span><span class=p>(</span><span class=mf>1.0f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>particle_id</span> <span class=o>&lt;</span> <span class=n>n_particle</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>position_self</span> <span class=o>=</span> <span class=n>position</span><span class=p>[</span><span class=n>particle_id</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>max_load</span> <span class=o>=</span> <span class=n>CHUNK_SIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>uint</span> <span class=n>half_chunk</span> <span class=o>=</span> <span class=mi>256</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>uint</span> <span class=n>fetch_id</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>uint</span> <span class=n>offset</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>offset</span> <span class=o>&lt;</span> <span class=p>(</span><span class=n>n_particle</span> <span class=o>+</span> <span class=n>CHUNK_SIZE</span><span class=p>);</span> <span class=n>offset</span><span class=o>+=</span><span class=n>CHUNK_SIZE</span><span class=p>){</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Load chunk
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>chunk_mass</span><span class=p>[</span><span class=n>local_id</span><span class=o>*</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=n>mass</span><span class=p>[</span><span class=n>local_id</span><span class=o>*</span><span class=mi>2</span> <span class=o>+</span> <span class=n>offset</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>chunk_position</span><span class=p>[</span><span class=n>local_id</span><span class=o>*</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=n>position</span><span class=p>[</span><span class=n>local_id</span><span class=o>*</span><span class=mi>2</span> <span class=o>+</span> <span class=n>offset</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>chunk_mass</span><span class=p>[</span><span class=n>local_id</span><span class=o>*</span><span class=mi>2</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>mass</span><span class=p>[</span><span class=n>local_id</span><span class=o>*</span><span class=mi>2</span> <span class=o>+</span><span class=mi>1</span> <span class=o>+</span> <span class=n>offset</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>chunk_position</span><span class=p>[</span><span class=n>local_id</span><span class=o>*</span><span class=mi>2</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>position</span><span class=p>[</span><span class=n>local_id</span><span class=o>*</span><span class=mi>2</span> <span class=o>+</span> <span class=mi>1</span><span class=o>+</span> <span class=n>offset</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>memoryBarrier</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>barrier</span><span class=p>();</span>
</span></span></code></pre></div><p>Here, each thread each load 2 pieces of data into shared memory per loop.
From here calculation of acceleration is done as usual.</p><h3 id=fine-grained-gpu-implementation>Fine-Grained GPU Implementation<a hidden class=anchor aria-hidden=true href=#fine-grained-gpu-implementation>#</a></h3><p>In this implementation, instead of using multiple particles per workgroup. I have decided to use 1 particle per work group. However, the amount work is equally distributed among threads.</p><p>In the first pass, we use the standard 256 particle per thread implementation to update the position and velocity.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>this</span><span class=o>-&gt;</span><span class=n>compute_shader_program</span><span class=p>.</span><span class=n>set_bool</span><span class=p>(</span><span class=s>&#34;first_pass&#34;</span><span class=p>,</span> <span class=nb>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>glDispatchCompute</span><span class=p>(</span><span class=k>this</span><span class=o>-&gt;</span><span class=n>n_work_groups</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>glMemoryBarrier</span><span class=p>(</span><span class=n>GL_SHADER_STORAGE_BARRIER_BIT</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>this</span><span class=o>-&gt;</span><span class=n>compute_shader_program</span><span class=p>.</span><span class=n>set_bool</span><span class=p>(</span><span class=s>&#34;first_pass&#34;</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>glDispatchCompute</span><span class=p>(</span><span class=k>this</span><span class=o>-&gt;</span><span class=n>n_particle</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span></code></pre></div><p>Afterwards, for the second pass, we have shared variable setup for accumulation.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>shared</span> <span class=n>vec4</span> <span class=n>local_acceleration_accumulator</span><span class=p>[</span><span class=mi>256</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=n>uint</span> <span class=n>particle_id</span> <span class=o>=</span> <span class=n>gl_WorkGroupID</span><span class=p>.</span><span class=n>x</span><span class=p>;</span>   
</span></span><span class=line><span class=cl><span class=n>uint</span> <span class=n>local_id</span> <span class=o>=</span> <span class=n>gl_LocalInvocationID</span><span class=p>.</span><span class=n>x</span><span class=p>;</span>
</span></span></code></pre></div><p>The acceleration calculation is then done by having each thread accumulate the acceleration based on their local id (workgroup ID ) then add this to the shared memory before proceeding to the next stage.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>uint</span> <span class=n>i</span> <span class=o>=</span> <span class=n>local_id</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>uint</span><span class=p>(</span><span class=n>n_particle</span><span class=p>);</span> <span class=n>i</span><span class=o>+=</span> <span class=mi>256</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>tmp_distance</span> <span class=o>=</span> <span class=n>position</span><span class=p>[</span><span class=n>particle_id</span><span class=p>]</span> <span class=o>-</span> <span class=n>position</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>tmp_distance</span> <span class=o>!=</span> <span class=n>vec4</span><span class=p>(</span><span class=mf>0.0</span><span class=p>)){</span>
</span></span><span class=line><span class=cl>            <span class=n>tmp_direction</span> <span class=o>=</span> <span class=o>-</span><span class=n>normalize</span><span class=p>(</span><span class=n>tmp_distance</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>sq_distance</span> <span class=o>=</span> <span class=n>dot</span><span class=p>(</span><span class=n>tmp_distance</span><span class=p>,</span><span class=n>tmp_distance</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>local_acceleration_sum</span> <span class=o>+=</span> <span class=p>(</span><span class=n>mass</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>/</span><span class=n>sqrt</span><span class=p>(</span><span class=n>sq_distance</span><span class=o>+</span><span class=n>sq_soften</span><span class=p>))</span> <span class=o>*</span> <span class=n>tmp_direction</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>local_acceleration_accumulator</span><span class=p>[</span><span class=n>local_id</span><span class=p>]</span> <span class=o>=</span> <span class=n>local_acceleration_sum</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>barrier</span><span class=p>();</span>
</span></span></code></pre></div><p>After accumulating all the acceleration locally, we then accumulate the acceleration using tree based reduction until acceleration at local_id 0 have the sum of all acceleration.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>uint</span> <span class=n>stride</span> <span class=o>=</span> <span class=mi>128</span><span class=p>;</span> <span class=n>stride</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>;</span> <span class=n>stride</span> <span class=o>&gt;&gt;=</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>local_id</span> <span class=o>&lt;</span> <span class=n>stride</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>local_acceleration_accumulator</span><span class=p>[</span><span class=n>local_id</span><span class=p>]</span> <span class=o>+=</span> <span class=n>local_acceleration_accumulator</span><span class=p>[</span><span class=n>local_id</span> <span class=o>+</span> <span class=n>stride</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>barrier</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>Afterwards we calculate the velocity as usual.</p><ul><li>Work: $O(n^2)$</li><li>Span: $O(n)$</li><li>Available Parallelism: $O(n)$</li></ul><h3 id=2-passes-and-global-synchronization>2 Passes and Global Synchronization<a hidden class=anchor aria-hidden=true href=#2-passes-and-global-synchronization>#</a></h3><p>Since the order of computation of velocity-verlet is</p><ol><li>Calculate half velocity</li><li>Calculate new position</li><li>Calculate acceleration</li><li>Calculate half velocity</li></ol><p>Between step 2 and 3, if some workgroup finishes faster than the other, we might have issue where the acceleration is calculated using the position other variables of the previous step creating minor accuracies that accumulate overtime.</p><p>To counter this issue, one way is to use 2 compute dispatch separated by global memory barrier.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>        <span class=k>this</span><span class=o>-&gt;</span><span class=n>compute_shader_program</span><span class=p>.</span><span class=n>set_bool</span><span class=p>(</span><span class=s>&#34;first_pass&#34;</span><span class=p>,</span> <span class=nb>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>glDispatchCompute</span><span class=p>(</span><span class=k>this</span><span class=o>-&gt;</span><span class=n>n_work_groups</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>glMemoryBarrier</span><span class=p>(</span><span class=n>GL_SHADER_STORAGE_BARRIER_BIT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>-&gt;</span><span class=n>compute_shader_program</span><span class=p>.</span><span class=n>set_bool</span><span class=p>(</span><span class=s>&#34;first_pass&#34;</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>glDispatchCompute</span><span class=p>(</span><span class=k>this</span><span class=o>-&gt;</span><span class=n>n_work_groups</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span></code></pre></div><p>something like this, to ensure that the value syncs before we update the next step.</p><h2 id=future-improvements>Future Improvements<a hidden class=anchor aria-hidden=true href=#future-improvements>#</a></h2><ul><li>Further optimization on the particle interaction calculations (use oct-tree, FMM, Barnes-Hut&mldr;)</li><li>More effects?</li><li>Save-Load system</li></ul><h3 id=known-issues>Known Issues<a hidden class=anchor aria-hidden=true href=#known-issues>#</a></h3><ul><li>If you set the velocity or mass to some crazy stuffs and you start to see some void ball in the middle of your screen, fear not for the stuffs is actually flying off the camera limit&mldr; ðŸ˜‚ [Will need to set world boundary probably]</li><li>The sphere is sampled usingÂ <code>glm::sphericalRand</code>Â so there is a gaping hole and a line on some position&mldr;</li><li>Particle-Particle NAIVE GPU have very minor inaccuracy issue due to being done in 1 pass</li></ul><h2 id=references-and-resources>References and Resources<a hidden class=anchor aria-hidden=true href=#references-and-resources>#</a></h2><p>Here are list of resources I read while researching on how to build this simulator, you will probably find them useful if you want to dive deeper into this subject!</p><ul><li><a href=https://learnopengl.com/>https://learnopengl.com/</a></li><li><a href=https://www.youtube.com/@OnurMutluLectures>https://www.youtube.com/@OnurMutluLectures</a></li><li><a href=https://en.wikipedia.org/wiki/n-body>https://en.wikipedia.org/wiki/n-body</a>Â problem. (n.d.).</li><li><a href=https://en.wikipedia.org/wiki/Leapfrog_integration>https://en.wikipedia.org/wiki/Leapfrog_integration</a></li><li>Dehnen, W., & Read, J. (2011). N-body simulations of gravitational dynamics. arxiv:1105.1082v1.</li><li>Brandt, A. (2022, 03). On distributed gravitational n-body simulations, arxiv:2203.08966.Â <a href=https://arxiv.org/pdf/2203.08966>https://arxiv.org/pdf/2203.08966</a></li><li>Computation and astrophysics of the n-body problem. (n.d.). Graps, A. (1996). N-body / particle simulation methods.Â <a href=https://www.cs.cmu.edu/afs/cs/academic/class/15850c-s96/www/nbody.html>https://www.cs.cmu.edu/afs/cs/academic/class/15850c-s96/www/nbody.html</a></li><li><a href=https://www.algorithm-archive.org/contents/verlet_integration/verlet_integration.html>https://www.algorithm-archive.org/contents/verlet_integration/verlet_integration.html</a></li><li><a href=https://developer.nvidia.com/gpugems/gpugems/part-vi-beyond-triangles/chapter-37-toolkit-computation-gpus>https://developer.nvidia.com/gpugems/gpugems/part-vi-beyond-triangles/chapter-37-toolkit-computation-gpus</a></li><li><a href=https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation/chapter-31-fast-n-body-simulation-cuda>https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation/chapter-31-fast-n-body-simulation-cuda</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://squidev.github.io/tags/opengl/>OpenGL</a></li><li><a href=https://squidev.github.io/tags/realtime/>RealTime</a></li><li><a href=https://squidev.github.io/tags/compute-shaders/>Compute Shaders</a></li><li><a href=https://squidev.github.io/tags/particle-system/>Particle System</a></li><li><a href=https://squidev.github.io/tags/post-processing/>Post-Processing</a></li></ul><nav class=paginav><a class=next href=https://squidev.github.io/posts/002_fishies_ocean/><span class=title>Next Â»</span><br><span>On Stylized Ocean Environment - Unreal Engine 5</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Simulating the Cosmos - N Body Simulation on x" href="https://x.com/intent/tweet/?text=Simulating%20the%20Cosmos%20-%20N%20Body%20Simulation&amp;url=https%3a%2f%2fsquidev.github.io%2fposts%2f001_n-body-simulation%2f&amp;hashtags=OpenGL%2cRealTime%2cComputeShaders%2cParticleSystem%2cPost-Processing"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Simulating the Cosmos - N Body Simulation on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsquidev.github.io%2fposts%2f001_n-body-simulation%2f&amp;title=Simulating%20the%20Cosmos%20-%20N%20Body%20Simulation&amp;summary=Simulating%20the%20Cosmos%20-%20N%20Body%20Simulation&amp;source=https%3a%2f%2fsquidev.github.io%2fposts%2f001_n-body-simulation%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Simulating the Cosmos - N Body Simulation on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fsquidev.github.io%2fposts%2f001_n-body-simulation%2f&title=Simulating%20the%20Cosmos%20-%20N%20Body%20Simulation"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Simulating the Cosmos - N Body Simulation on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsquidev.github.io%2fposts%2f001_n-body-simulation%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Simulating the Cosmos - N Body Simulation on whatsapp" href="https://api.whatsapp.com/send?text=Simulating%20the%20Cosmos%20-%20N%20Body%20Simulation%20-%20https%3a%2f%2fsquidev.github.io%2fposts%2f001_n-body-simulation%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Simulating the Cosmos - N Body Simulation on telegram" href="https://telegram.me/share/url?text=Simulating%20the%20Cosmos%20-%20N%20Body%20Simulation&amp;url=https%3a%2f%2fsquidev.github.io%2fposts%2f001_n-body-simulation%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Simulating the Cosmos - N Body Simulation on ycombinator" href="https://news.ycombinator.com/submitlink?t=Simulating%20the%20Cosmos%20-%20N%20Body%20Simulation&u=https%3a%2f%2fsquidev.github.io%2fposts%2f001_n-body-simulation%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://squidev.github.io/>Squidev-Blog</a></span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>