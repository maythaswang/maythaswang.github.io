<!DOCTYPE html>
<html lang="ja" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>宇宙のシミュレーション - N体シミュレーション | Blog</title>
<meta name="keywords" content="OpenGL, RealTime, Compute Shaders, Particle System, Post-Processing, Optimization">
<meta name="description" content="リアルタイム重力N体シミュレーター - OpenGLグラフィックスパイプライン及びGLSLコンピュートシェーダーによる加速">
<meta name="author" content="Maythas Wangcharoenwong">
<link rel="canonical" href="https://maythaswang.github.io/ja/posts/001_n-body-simulation/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://maythaswang.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://maythaswang.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://maythaswang.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://maythaswang.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://maythaswang.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://maythaswang.github.io/posts/001_n-body-simulation/">
<link rel="alternate" hreflang="ja" href="https://maythaswang.github.io/ja/posts/001_n-body-simulation/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="" crossorigin="anonymous">
    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="" crossorigin="anonymous"></script>
    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>

    
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
    </script>
<meta property="og:url" content="https://maythaswang.github.io/ja/posts/001_n-body-simulation/">
  <meta property="og:site_name" content="Blog">
  <meta property="og:title" content="宇宙のシミュレーション - N体シミュレーション">
  <meta property="og:description" content="リアルタイム重力N体シミュレーター - OpenGLグラフィックスパイプライン及びGLSLコンピュートシェーダーによる加速">
  <meta property="og:locale" content="ja">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-06-02T22:11:31+07:00">
    <meta property="article:modified_time" content="2025-06-02T22:11:31+07:00">
    <meta property="article:tag" content="OpenGL">
    <meta property="article:tag" content="RealTime">
    <meta property="article:tag" content="Compute Shaders">
    <meta property="article:tag" content="Particle System">
    <meta property="article:tag" content="Post-Processing">
    <meta property="article:tag" content="Optimization">
    <meta property="og:image" content="https://maythaswang.github.io/001_N-body-simulation/thumbnail.webp">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://maythaswang.github.io/001_N-body-simulation/thumbnail.webp">
<meta name="twitter:title" content="宇宙のシミュレーション - N体シミュレーション">
<meta name="twitter:description" content="リアルタイム重力N体シミュレーター - OpenGLグラフィックスパイプライン及びGLSLコンピュートシェーダーによる加速">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://maythaswang.github.io/ja/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "宇宙のシミュレーション - N体シミュレーション",
      "item": "https://maythaswang.github.io/ja/posts/001_n-body-simulation/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "宇宙のシミュレーション - N体シミュレーション",
  "name": "宇宙のシミュレーション - N体シミュレーション",
  "description": "リアルタイム重力N体シミュレーター - OpenGLグラフィックスパイプライン及びGLSLコンピュートシェーダーによる加速",
  "keywords": [
    "OpenGL", "RealTime", "Compute Shaders", "Particle System", "Post-Processing", "Optimization"
  ],
  "articleBody": "概要 このプロジェクトでは、リアルタイムグラフィックエンジンと高性能パーティクルシステムを開発し、重力の影響を受ける星々の動きをシミュレーションしています。\n性能を最大限に引き出すため、GLSLコンピュートシェーダーを用いてGPUを活用し、6.5万個のパーティクルを60FPS以上でシミュレーションすることができ、その結果、通常のCPU実装（数千個のパーティクルが限界）よりも高い性能を実現しました。\nビジュアルの向上のために、GPU Instancingを使用し、各パーティクルの位置でメッシュをレンダリングすることができます。この方法により、 約1,092万ポリゴン （6.5万パーティクル）を効率よくレンダリングすることができます。さらに、Post Processing (ガウスぼかし、ブルーム）、HDR トーンマッピング、及び Exposure コントロールを実装しました。加えて、ImGUIベースのUIと２種類のカメラモードも備えます。\n※Youtubeの圧縮で映像があまりきれいに見えないかもしれません。スマホなど小さな画面で見るのがおすすめです。\nソースコードはこのリンクからご覧いただけます: N体シミュレーション\n※この記事の内容は英語でまとめています。ご興味のある方はぜひご覧ください。\nPreface This project is basical*y an educational project for me to learn how to properly use compute shaders, OpenGL, Post processing effects to make a visually stunning particle simulations. First, I must say that Physics is not my strong suit. With that given, the real aim of this project is to produce visually interesting simulation, not full physics accuracy (although I tried to be as accurate as possible). In a sense, the value in those of default test cases are extremely exaggerated so please be aware of this fact. As per the geometries of stellar clusters and how mass are mapped to colors, these are not fully accurate as well (To any physicist out there I am sorry (´；ω；｀)). With that being said, the project provides multiple controllable variables for those who want to try setup the simulation for themselves as well as multiple default test cases to pick from so enjoy!! (*´ω｀*)\nWhat is an N-body simulation The basic premises of an N-body simulation is, given an arbitrary number of particles n in a system, each and every particle in this system will interact with each other by some physical forces, which in our case is gravity. Generally this simulation is used as a tool to study dynamical system of particles, especially in fields such as astrophysics, cosmology, and molecular dynamics.\nProject Scope In this project, I have implemented a gravitational n-body variant of the simulation with the initial purpose to visually predict the motion of celestial bodies interacting with each other through gravity. The simulation is strictly gravitational using only Classical mechanics meaning there will be no collision and no insane objects like dark matter, dark energy, etc…\nImplementation Methodologies Due to the fact that currently there exist no closed-form solution for calculating the position of every particle in a dynamic system where n\u003e2 (excluding some specific n = 3 ones). In our n-body system, we instead predict the position of each particle on the next time step based on their acceleration, velocity, and current position using something called a numerical integrator. However, in order to calculate the acceleration, we need to calculate the force of each particle which leads us to the topic of calculating force between each particle.\nfigure 0: Simulation GUI Calculating Gravitational Force Recall Newton’s universal law of gravitation. Let $r$ be the distance between the two particle and $m$ be the mass.\n$$F= \\frac{Gm_im_j}{r^2}$$\nTo calculate the force of one particle exerting on another ($m_j$ on $m_i$) $$F_{ij} = \\frac{Gm_im_j}{||r_i-r_j||^2}\\cdot -\\hat{r_{ij}}$$ $$ F_{ij} = \\frac{Gm_im_j}{||r_i - r_j||^2} \\cdot \\frac{-(r_i-r_j)}{||r_i-r_j||}$$ Using Newton’s second law of motion, we can derive the formula to calculate the acceleration of the particle using the accumulated force. $$F_{ij} = m_ia_{ij}$$ $$a_{ij} = \\frac{F_{ij}}{m_i}$$ Here we can now calculate the force acting on the current particle $i$ from other particles. Let there be a particle $i$ and let $K$ be a set of particles where $|K| = n-1, i \\notin K, \\forall j \\in K$. The acceleration of $i$ can now be calculate (accumulate) as follows. $$a_i = \\sum_{j \\ne i}^K a_{ij} \\text{\\quad;\\quad} a_im_i= \\sum_{j \\ne i}^K F_{ij}$$ $$a_i = \\frac{1}{m_i} \\sum_{j \\ne i}^k F_{ij} = \\frac{1}{m_i} \\sum_{j \\ne i}^k \\frac{Gm_im_j}{||r_i - r_j||^2} \\cdot -\\hat{r}_{ij}$$\n$$= G \\sum_{j \\ne i}^k \\frac{m_j}{||r_i - r_j||^2} \\cdot -\\hat{r}_{ij}$$\nThis can now be used to determine the acceleration of $\\forall i$ in the system. Using this formula, we can calculate naively calculate acceleration of the particles using the particle-particle method, or aka. calculate all pairs. This however would be very computationally expensive having a complexity of $O(n^2)$ making the system not so scalable. In favor of performance, we could choose to opt to use methods such as Barnes-Hut or FMM that utilizes data structures such as Oct-tree to decrease the time complexity to $O(nlog(n))$ and $O(n)$ in some special case respectively. However, since I am new to compute shaders, I chose to go with the naive $O(n^2)$ method first.\nNumerical Integrator Since we now know how to calculate the acceleration, we now need to calculate the position and velocity of the particle. As for the current, there are multiple numerical integrator that can be used to address issue by approximately the velocity based on the initial information given at each timestep and proceed them based on the size of each time step.\nThere are multiple integrator available for physics simulation:\nEuler Integrator Velocity-Verlet Integrator RK4(Runge-Kutta 4th order) Hermite etc… In this simulator, I’ve implemented the following two integrators:\nSemi-Implicit Euler method The idea of Euler Method is the simplest and cheapest to compute but also the most inaccurate among all aforementioned integrators due to the linearly accumulating error and inability to conserve energy. The Semi-Implicit Euler Method however conserve energy better than the standard implementation just by simply updating the velocity before position at every step (explicit version does the opposite). $$v_{i+1} = v_i + a_i * \\Delta t $$ $$r_{i+1} = r_{i} + v_{i+1} * \\Delta t$$\nThis method is a 1st order meaning:\nLocal error: $O(\\Delta t^2)$ Global error: $O(\\Delta t$) Velocity-Verlet (KDK-Leapfrog) Also known as Kick-Drift-Kick Leapfrog. This method is almost as computationally cheap as Euler, however it is a 2nd order method that also conserves energy making it more accurate. To calculate the velocity and position, simply: $$v_{i+\\frac{1}{2}} = v_i + 0.5 * a_i * \\Delta t$$ $$r_{i+1} = r_i + v_{i+\\frac{1}{2}} * \\Delta t$$ $$a_{i+1} = \\text{acceleration using the new position } r_{i+1}$$ $$v_{i+1} = v_{i+\\frac{1}{2}} + 0.5 * a_i * \\Delta t$$\nThis method is a 2nd order method meaning\nLocal error: $O(\\Delta t^3)$ Global error: $O(\\Delta t^2)$ Engine Implementation This project features a custom-built engine that serves as the core driver for the simulation. It is designed to model and render gravitational interactions of large clusters of celestial bodies in real-time. The engine leverages GPU acceleration through custom-written compute shaders as well as implementing techniques such as instancing and post-processing to improve the visual fidelity. The following section will explain the engine’s architecture and other important information.\nDependencies and Tools GLAD and GLFW for setting up and managing the OpenGL context GLM for mathematic operations. ImGui for the Graphical User Interface (GUI) Modules Brief Execution Flow The modules in this engine can be grouped into 5 parts as shown in the figure above.\nThe Graphics Components Modules Responsible for rendering frames to the window, managing mesh instancing, and applying post-processing effects such as bloom to enhance the visual fidelity of the simulation. The Physics Simulator Modules Responsible for handling the calculation of the dynamical system based on the chosen implementation and integrators. The User input and display information Modules Responsible for accepting user input from mouse control, keyboard input, and GUI toggles. Updates simulation and display statuses according to the user input and show the current state of the engine to the user through GUI. The simulation initializer Modules Responsible for taking in user input for initializing the particle data such as the geometry of the cluster, mass range, velocity range, number of particles for the simulator. The standalone program initializer Modules Initialize OpenGL context, creating windows, and initializing required components for sphere instancing. The Enums and Structs Modules Serves as data payload when transferring data between modules. The Graphics and Physics Modules are designed to be independent from each other ensuring ease of modification. The User input and Display information modules however are more tightly coupled with multiple other modules due to being the interface between the users and the engine. As a result, changes in other modules would often require update in this one.\nVery Brief Execution flow and Render Loop Brief Execution Flow Shader Pipeline and Post-Processing The post-processing effect implemented for this engine is, for the moment just bloom and some color correction features.\nBloom figure 2: Bloom off vs on The idea of bloom is mostly simple. We first render the scene onto 2 separated textures. For the first texture, we keep it as the original. For the second texture, we do 2 passes gaussian blur based on the intensity we want. Afterwards we combine the two texture and do some color correction and now we have a functioning bloom output that can be used to draw on a quad.\nPipeline Rendering Pipeline In this pipeline, we can split it into 2 main paths.\nBloom enabled: The main idea is basically we draw to a texture as an output, afterwards we use the texture rendered as quad for the following steps. ※ Do note that the $n/2$ in the image above is just a simplification\nglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, tex_id, 0); In this case we have to bind the render of the output to bloom shader with no Color correction (tone mapping and gamma correction) to a texture. After that we use one of the textures to do 2 passes blur for a number of times. After which we combines the output with the original texture then do the color correction and renders onto a quad. void calc_gaussian_kernel(){ for(int i = 0; i \u003c BLUR_RADIUS; i++){ weight[i] = exp(-0.5*(pow(i/sigma,2)))/ (sqrt(2*3.141592653589793)*sigma) ; } } void main(){ calc_gaussian_kernel(); vec2 tex_offset = 1.0 / textureSize(u_prev_texture, 0); //size of texel vec3 color = texture(u_prev_texture, tex_coord).rgb * weight[0]; if(is_horizontal){ for(int i = 1; i \u003c BLUR_RADIUS; i++){ color += texture(u_prev_texture, tex_coord + vec2(tex_offset.x * i,0)).rgb * weight[i]; color += texture(u_prev_texture, tex_coord - vec2(tex_offset.x * i,0)).rgb * weight[i]; } } else { // vertical for(int i = 1; i \u003c BLUR_RADIUS; i++){ color += texture(u_prev_texture, tex_coord + vec2(0, tex_offset.y * i)).rgb * weight[i]; color += texture(u_prev_texture, tex_coord - vec2(0, tex_offset.y * i)).rgb * weight[i]; } } FragColor = vec4(color,1.0f); } Important Notes\n※ Disable depth test before drawing to a quad (rectangle) Ensure you bind an RBO to the original scene FBO too otherwise we will some issue with depth Bloom disabled: Directly follow the path marked in green and render the scene out with color correction. HDR, Exposure Tone Mapping and Gamma Correction The color of the stars defined in HDR range\nvec3 yellow =vec3(5.0f, 2.0f, 0.24f); ... In this case we have to perform exposure tone-mapping to allow the brightness of scene to be displayed within range of a standard screen [0,1]\ncolor = vec3(1.0) - exp(-color * u_exposure); Afterwards, gamma correction is then applied to ensure the color to appear correctly on standard screen.\ncolor = pow(color, vec3(1.0/u_gamma)); Instancing Instancing is simple, in this case we just instance all the particles as a sphere using the VAO we bind earlier and draw elements using glDrawElementsInstanced, on the Shader side, we just simply scale the vertices of the sphere by its mass then offset them by the position stored in the SSBO.\nfigure 2: Instancing (+Wireframe) off vs on // CPU side if (!this-\u003euse_instancing) { this-\u003eshader_program-\u003eset_bool(\"use_instancing\", this-\u003euse_instancing); glDrawArrays(GL_POINTS, 0, this-\u003esimulator-\u003eget_n_particle()); } else { this-\u003eshader_program-\u003eset_bool(\"use_instancing\", !this-\u003euse_instancing); glDrawArrays(GL_POINTS, 0, this-\u003esimulator-\u003eget_n_particle()); this-\u003eshader_program-\u003eset_bool(\"use_instancing\", this-\u003euse_instancing); glDrawElementsInstanced(GL_TRIANGLES, 3 * this-\u003erender_components-\u003en_inds, GL_UNSIGNED_INT, (void *)0, this-\u003esimulator-\u003eget_n_particle()); } //light.vs layout (std430, binding = 0) buffer particle_position { vec4 position[]; }; //Check the full version on my repository ... ... ... if(!use_instancing){ new_pos = position[gl_VertexID]; star_mass = mass[gl_VertexID]; } else { if(use_mass_size){ mass_size += calculate_mass_scaler(gl_InstanceID); } new_pos = position[gl_InstanceID] + vec4(mass_size * v_pos,1.0); star_mass = mass[gl_InstanceID]; } Why draw twice when instancing (specifically for our case) Currently, we have no boundary set for our simulation meaning that once a particle moves away from the screen, it gets too tiny to get rendered onto the screen. With this issue in mind, we simply use glDrawArrays(GL_POINTS...) first to ensure that there will at least be something drawn to the screen at minimum size. Afterwards we draw the instanced version on top of the dot version. Doing this will ensure that for any area of the screen where the instanced particles are drawn, the point version will completely be blocked.\nOne draw call vs double draw call GPU optimization and performance Performance Due to time constraint, I have yet to make proper benchmarking scripts or setting up Nsight for performance profiling. The performance was recorded manually and averaged on the hardware this simulation was implemented in (RTX4070Ti GPU).\nThe FPS are written in format . These numbers should give a rough idea on how it should perform given this specific hardware.\n# Particles / Implementation (FPS) CPU Naive Particle-Particle GPU Naive Particle-Particle GPU Tiling Particle-Particle GPU Fine-Grain Particle-Particle n = 100 120 120 120 120 n = 1000 90-91 120 120 120 n = 10000 1 120 120 120 n = 30000 - 120 120 120 n = 50000 - 88 ~ 100 117 ~ 120 109 ~ 120 n = 65000 - 57 ~ 63 66 ~ 74 68 ~ 75 n = 100000 - 23 ~ 23 37 ~ 40 30 ~ 32 n = 150000 - 12 ~ 12 17 ~ 18 14 ~ 14 n = 200000 - 7 ~ 7 8 ~ 8 8 ~ 8 Naive GPU Implementation The naive implementation uses 1 workgroup per 64 particle. The idea is basically using velocity-verlet integrator to calculate the next step without further optimization.\nThis version does introduce some inaccuracies as well (I have yet to fix this). This is due to the fact that barrier only blocks the threads in the same workgroup, not globally, meaning that there can be some case of race conditions where position is used to calculate acceleration before some is updated.\nWork: $O(n^2)$ Span: $O(n)$ Available Parallelism: $O(n)$ uint id = gl_GlobalInvocationID.x; if (id \u003e= n_particle) return ; velocity[id] += acceleration[id] * timestep_size * 0.5; position[id] += velocity[id] * timestep_size; memoryBarrier(); barrier(); acceleration[id] = calculate_acceleration(id) * gravitational_constant; memoryBarrier(); barrier(); velocity[id] += acceleration[id] * timestep_size * 0.5; Tiling - Chunk Optimized GPU Implementation In this implementation, the idea of tiling in chunks into the shared memory has been introduced. Since fetching data repeatedly from global memory is an expensive operation. Having multiple threads in the same group collectively fetch a chunk of data into shared memory where the threads inside the same workgroup can access to calculate acceleration. This approach is likely a better approach since it reduces the amount of fetching needed to be done from global memory. This version is implemented in 2 passes.\nIn my case, a chunk-size of 512 and a workgroup of size x=256 seems to be the best performing settings.\nconst int CHUNK_SIZE = 512; shared vec4 chunk_position[CHUNK_SIZE]; shared float chunk_mass[CHUNK_SIZE]; void main(){.... uint particle_id = gl_GlobalInvocationID.x; uint local_id = gl_LocalInvocationID.x; Work: $O(n^2)$ Span: $O(n)$ Available Parallelism: $O(n)$ // Pre-load position of current particle if valid vec4 position_self = vec4(1.0f); if(particle_id \u003c n_particle){ position_self = position[particle_id]; } int max_load = CHUNK_SIZE; uint half_chunk = 256; uint fetch_id = 0; for (uint offset = 0; offset \u003c (n_particle + CHUNK_SIZE); offset+=CHUNK_SIZE){ // Load chunk chunk_mass[local_id*2] = mass[local_id*2 + offset]; chunk_position[local_id*2] = position[local_id*2 + offset]; chunk_mass[local_id*2+1] = mass[local_id*2 +1 + offset]; chunk_position[local_id*2+1] = position[local_id*2 + 1+ offset]; memoryBarrier(); barrier(); Here, each thread each load 2 pieces of data into shared memory per loop. From here calculation of acceleration is done as usual.\nFine-Grained GPU Implementation In this implementation, instead of using multiple particles per workgroup. I have decided to use 1 particle per work group. However, the amount work is equally distributed among threads.\nIn the first pass, we use the standard 256 particle per thread implementation to update the position and velocity.\nthis-\u003ecompute_shader_program.set_bool(\"first_pass\", true); glDispatchCompute(this-\u003en_work_groups, 1, 1); glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT); this-\u003ecompute_shader_program.set_bool(\"first_pass\", false); glDispatchCompute(this-\u003en_particle, 1, 1); Afterwards, for the second pass, we have shared variable setup for accumulation.\nshared vec4 local_acceleration_accumulator[256]; uint particle_id = gl_WorkGroupID.x; uint local_id = gl_LocalInvocationID.x; The acceleration calculation is then done by having each thread accumulate the acceleration based on their local id (workgroup ID ) then add this to the shared memory before proceeding to the next stage.\nfor (uint i = local_id; i \u003c uint(n_particle); i+= 256){ tmp_distance = position[particle_id] - position[i]; if(tmp_distance != vec4(0.0)){ tmp_direction = -normalize(tmp_distance); sq_distance = dot(tmp_distance,tmp_distance); local_acceleration_sum += (mass[i]/sqrt(sq_distance+sq_soften)) * tmp_direction; } } local_acceleration_accumulator[local_id] = local_acceleration_sum; barrier(); After accumulating all the acceleration locally, we then accumulate the acceleration using tree based reduction until acceleration at local_id 0 have the sum of all acceleration.\nfor (uint stride = 128; stride \u003e 0; stride \u003e\u003e=1) { if(local_id \u003c stride){ local_acceleration_accumulator[local_id] += local_acceleration_accumulator[local_id + stride]; } barrier(); } Afterwards we calculate the velocity as usual.\nWork: $O(n^2)$ Span: $O(n)$ Available Parallelism: $O(n)$ 2 Passes and Global Synchronization Since the order of computation of velocity-verlet is\nCalculate half velocity Calculate new position Calculate acceleration Calculate half velocity Between step 2 and 3, if some workgroup finishes faster than the other, we might have issue where the acceleration is calculated using the position other variables of the previous step creating minor accuracies that accumulate overtime.\nTo counter this issue, one way is to use 2 compute dispatch separated by global memory barrier.\nthis-\u003ecompute_shader_program.set_bool(\"first_pass\", true); glDispatchCompute(this-\u003en_work_groups, 1, 1); glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT); this-\u003ecompute_shader_program.set_bool(\"first_pass\", false); glDispatchCompute(this-\u003en_work_groups, 1, 1); something like this, to ensure that the value syncs before we update the next step.\nFuture Improvements Further optimization on the particle interaction calculations (use oct-tree, FMM, Barnes-Hut…) More effects? Save-Load system Known Issues If you set the velocity or mass to some crazy stuffs and you start to see some void ball in the middle of your screen, fear not for the stuffs is actually flying off the camera limit… 😂 [Will need to set world boundary probably] The sphere is sampled using glm::sphericalRand so there is a gaping hole and a line on some position… Particle-Particle NAIVE GPU have very minor inaccuracy issue due to being done in 1 pass References and Resources Here are list of resources I read while researching on how to build this simulator, you will probably find them useful if you want to dive deeper into this subject!\nhttps://learnopengl.com/ https://www.youtube.com/@OnurMutluLectures https://en.wikipedia.org/wiki/n-body problem. (n.d.). https://en.wikipedia.org/wiki/Leapfrog_integration Dehnen, W., \u0026 Read, J. (2011). N-body simulations of gravitational dynamics. arxiv:1105.1082v1. Brandt, A. (2022, 03). On distributed gravitational n-body simulations, arxiv:2203.08966. https://arxiv.org/pdf/2203.08966 Computation and astrophysics of the n-body problem. (n.d.). Graps, A. (1996). N-body / particle simulation methods. https://www.cs.cmu.edu/afs/cs/academic/class/15850c-s96/www/nbody.html https://www.algorithm-archive.org/contents/verlet_integration/verlet_integration.html https://developer.nvidia.com/gpugems/gpugems/part-vi-beyond-triangles/chapter-37-toolkit-computation-gpus https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation/chapter-31-fast-n-body-simulation-cuda ",
  "wordCount" : "3014",
  "inLanguage": "ja",
  "image":"https://maythaswang.github.io/001_N-body-simulation/thumbnail.webp","datePublished": "2025-06-02T22:11:31+07:00",
  "dateModified": "2025-06-02T22:11:31+07:00",
  "author":[{
    "@type": "Person",
    "name": "Maythas Wangcharoenwong"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://maythaswang.github.io/ja/posts/001_n-body-simulation/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://maythaswang.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://maythaswang.github.io/ja/" accesskey="h" title="Blog (Alt + H)">Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://maythaswang.github.io/" title="English"
                            aria-label="English">English</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://maythaswang.github.io/ja/tags/" title="タグ">
                    <span>タグ</span>
                </a>
            </li>
            <li>
                <a href="https://maythaswang.github.io/ja/archives/" title="アーカイブ">
                    <span>アーカイブ</span>
                </a>
            </li>
            <li>
                <a href="https://maythaswang.github.io/ja/about/" title="プロフィール">
                    <span>プロフィール</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://maythaswang.github.io/ja/">ホーム</a>&nbsp;»&nbsp;<a href="https://maythaswang.github.io/ja/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      宇宙のシミュレーション - N体シミュレーション
    </h1>
    <div class="post-description">
      リアルタイム重力N体シミュレーター - OpenGLグラフィックスパイプライン及びGLSLコンピュートシェーダーによる加速
    </div>
    <div class="post-meta"><span title='2025-06-02 22:11:31 +0700 +07'>6月 2, 2025</span>&nbsp;·&nbsp;15 分&nbsp;·&nbsp;3014 文字&nbsp;·&nbsp;Maythas Wangcharoenwong&nbsp;|&nbsp;言語:
<ul class="i18n_list">
    <li>
        <a href="https://maythaswang.github.io/posts/001_n-body-simulation/">English</a>
    </li>
</ul>

</div>
  </header> 
<figure class="entry-cover">
        <a href="https://maythaswang.github.io/001_N-body-simulation/thumbnail.webp" target="_blank" rel="noopener noreferrer">
        <img loading="eager" src="https://maythaswang.github.io/001_N-body-simulation/thumbnail.webp" alt="N-body simulation default test 30">
        </a>
        
</figure><div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目次</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#概要">概要</a></li>
    <li><a href="#preface">Preface</a></li>
    <li><a href="#what-is-an-n-body-simulation">What is an N-body simulation</a></li>
    <li><a href="#project-scope">Project Scope</a></li>
    <li><a href="#implementation-methodologies">Implementation Methodologies</a>
      <ul>
        <li><a href="#calculating-gravitational-force">Calculating Gravitational Force</a></li>
        <li><a href="#numerical-integrator">Numerical Integrator</a></li>
      </ul>
    </li>
    <li><a href="#engine-implementation">Engine Implementation</a>
      <ul>
        <li><a href="#dependencies-and-tools">Dependencies and Tools</a></li>
        <li><a href="#modules">Modules</a></li>
        <li><a href="#very-brief-execution-flow-and-render-loop">Very Brief Execution flow and Render Loop</a></li>
      </ul>
    </li>
    <li><a href="#shader-pipeline-and-post-processing">Shader Pipeline and Post-Processing</a>
      <ul>
        <li><a href="#bloom">Bloom</a></li>
        <li><a href="#pipeline">Pipeline</a></li>
        <li><a href="#hdr-exposure-tone-mapping-and-gamma-correction">HDR, Exposure Tone Mapping and Gamma Correction</a></li>
      </ul>
    </li>
    <li><a href="#instancing">Instancing</a>
      <ul>
        <li><a href="#why-draw-twice-when-instancing-specifically-for-our-case">Why draw twice when instancing (specifically for our case)</a></li>
      </ul>
    </li>
    <li><a href="#gpu-optimization-and-performance">GPU optimization and performance</a>
      <ul>
        <li><a href="#performance">Performance</a></li>
        <li><a href="#naive-gpu-implementation">Naive GPU Implementation</a></li>
        <li><a href="#tiling---chunk-optimized-gpu-implementation">Tiling - Chunk Optimized GPU Implementation</a></li>
        <li><a href="#fine-grained-gpu-implementation">Fine-Grained GPU Implementation</a></li>
        <li><a href="#2-passes-and-global-synchronization">2 Passes and Global Synchronization</a></li>
      </ul>
    </li>
    <li><a href="#future-improvements">Future Improvements</a>
      <ul>
        <li><a href="#known-issues">Known Issues</a></li>
      </ul>
    </li>
    <li><a href="#references-and-resources">References and Resources</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="概要">概要<a hidden class="anchor" aria-hidden="true" href="#概要">#</a></h2>
<p>このプロジェクトでは、リアルタイムグラフィックエンジンと高性能パーティクルシステムを開発し、重力の影響を受ける星々の動きをシミュレーションしています。</p>
<p>性能を最大限に引き出すため、GLSLコンピュートシェーダーを用いてGPUを活用し、6.5万個のパーティクルを60FPS以上でシミュレーションすることができ、その結果、通常のCPU実装（数千個のパーティクルが限界）よりも高い性能を実現しました。</p>
<p>ビジュアルの向上のために、GPU Instancingを使用し、各パーティクルの位置でメッシュをレンダリングすることができます。この方法により、 約1,092万ポリゴン （6.5万パーティクル）を効率よくレンダリングすることができます。さらに、Post Processing (ガウスぼかし、ブルーム）、HDR トーンマッピング、及び Exposure コントロールを実装しました。加えて、ImGUIベースのUIと２種類のカメラモードも備えます。</p>
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/zHSgu5Cd_NQ?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"></iframe>
    </div>

<p>※Youtubeの圧縮で映像があまりきれいに見えないかもしれません。スマホなど小さな画面で見るのがおすすめです。</p>
<p>ソースコードはこのリンクからご覧いただけます: <strong><a href="https://github.com/maythaswang/N-body-simulator">N体シミュレーション</a></strong></p>
<p>※この記事の内容は英語でまとめています。ご興味のある方はぜひご覧ください。</p>
<h2 id="preface">Preface<a hidden class="anchor" aria-hidden="true" href="#preface">#</a></h2>
<p>This project is basical*y an educational project for me to learn how to properly use compute shaders, OpenGL, Post processing effects to make a visually stunning particle simulations. First, I must say that Physics is not my strong suit. With that given, the real aim of this project is to produce visually interesting simulation, not full physics accuracy (although I tried to be as accurate as possible). In a sense, the value in those of default test cases are extremely exaggerated so please be aware of this fact. As per the geometries of stellar clusters and how mass are mapped to colors, these are not fully accurate as well (To any physicist out there I am sorry (´；ω；｀)). With that being said, the project provides multiple controllable variables for those who want to try setup the simulation for themselves as well as multiple default test cases to pick from so enjoy!! (*´ω｀*)</p>
<h2 id="what-is-an-n-body-simulation">What is an N-body simulation<a hidden class="anchor" aria-hidden="true" href="#what-is-an-n-body-simulation">#</a></h2>
<p>The basic premises of an N-body simulation is, given an arbitrary number of particles <em>n</em> in a system, each and every particle in this system will interact with each other by some physical forces, which in our case is gravity. Generally this simulation is used as a tool to study dynamical system of particles, especially in fields such as astrophysics, cosmology, and molecular dynamics.</p>
<h2 id="project-scope">Project Scope<a hidden class="anchor" aria-hidden="true" href="#project-scope">#</a></h2>
<p>In this project, I have implemented a gravitational n-body variant of the simulation with the initial purpose to visually predict the motion of celestial bodies interacting with each other through gravity.  The simulation is strictly gravitational using only Classical mechanics meaning there will be no collision and no insane objects like dark matter, dark energy, etc&hellip;</p>
<h2 id="implementation-methodologies">Implementation Methodologies<a hidden class="anchor" aria-hidden="true" href="#implementation-methodologies">#</a></h2>
<p>Due to the fact that currently there exist no closed-form solution for calculating the position of every particle in a dynamic system where n&gt;2 (excluding some specific n = 3 ones). In our n-body system, we instead predict the position of each particle on the next time step based on their acceleration, velocity, and current position using something called a numerical integrator. However, in order to calculate the acceleration, we need to calculate the force of each particle which leads us to the topic of calculating force between each particle.</p>
<p align="center">
    <img src="/001_N-body-simulation/GUI_example.webp" loading="lazy" alt="GUI_example">
    <br>
    <i>figure 0: Simulation GUI</i>
    </p>
<br>
<h3 id="calculating-gravitational-force">Calculating Gravitational Force<a hidden class="anchor" aria-hidden="true" href="#calculating-gravitational-force">#</a></h3>
<p>Recall Newton&rsquo;s universal law of gravitation. Let $r$ be the distance between the two particle and $m$ be the mass.</p>
<p>$$F= \frac{Gm_im_j}{r^2}$$</p>
<p>To calculate the force of one particle exerting on another ($m_j$ on $m_i$)
$$F_{ij} = \frac{Gm_im_j}{||r_i-r_j||^2}\cdot -\hat{r_{ij}}$$
$$ F_{ij} = \frac{Gm_im_j}{||r_i - r_j||^2} \cdot \frac{-(r_i-r_j)}{||r_i-r_j||}$$
Using Newton&rsquo;s second law of motion, we can derive the formula to calculate the acceleration of the particle using the accumulated force.
$$F_{ij} = m_ia_{ij}$$
$$a_{ij} = \frac{F_{ij}}{m_i}$$
Here we can now calculate the force acting on the current particle $i$ from other particles.
Let there be a particle $i$ and let $K$ be a set of particles where $|K| = n-1, i \notin K, \forall j \in K$. The acceleration of $i$ can now be calculate (accumulate) as follows.
$$a_i = \sum_{j \ne i}^K a_{ij} \text{\quad;\quad} a_im_i= \sum_{j \ne i}^K F_{ij}$$
$$a_i = \frac{1}{m_i} \sum_{j \ne i}^k F_{ij} = \frac{1}{m_i} \sum_{j \ne i}^k \frac{Gm_im_j}{||r_i - r_j||^2} \cdot -\hat{r}_{ij}$$</p>
<p>$$= G \sum_{j \ne i}^k \frac{m_j}{||r_i - r_j||^2} \cdot -\hat{r}_{ij}$$</p>
<p>This can now be used to determine the acceleration of $\forall i$ in the system.
Using this formula, we can calculate naively calculate acceleration of the particles using the particle-particle method, or aka. calculate all pairs. This however would be very computationally expensive having a complexity of $O(n^2)$ making the system not so scalable. In favor of performance, we could choose to opt to use methods such as Barnes-Hut or FMM that utilizes data structures such as Oct-tree to decrease the time complexity to $O(nlog(n))$ and $O(n)$ in some special case respectively. However, since I am new to compute shaders, I chose to go with the naive $O(n^2)$ method first.</p>
<h3 id="numerical-integrator">Numerical Integrator<a hidden class="anchor" aria-hidden="true" href="#numerical-integrator">#</a></h3>
<p>Since we now know how to calculate the acceleration, we now need to calculate the position and velocity of the particle. As for the current, there are multiple numerical integrator that can be used to address issue by approximately the velocity based on the initial information given at each timestep and proceed them based on the size of each time step.</p>
<p>There are multiple integrator available for physics simulation:</p>
<ul>
<li>Euler Integrator</li>
<li>Velocity-Verlet Integrator</li>
<li>RK4(Runge-Kutta 4th order)</li>
<li>Hermite</li>
<li>etc&hellip;</li>
</ul>
<p>In this simulator, I&rsquo;ve implemented the following two integrators:</p>
<h4 id="semi-implicit-euler-method">Semi-Implicit Euler method<a hidden class="anchor" aria-hidden="true" href="#semi-implicit-euler-method">#</a></h4>
<p>The idea of Euler Method is the simplest and cheapest to compute but also the most inaccurate among all aforementioned integrators due to the linearly accumulating error and inability to conserve energy. The Semi-Implicit Euler Method however conserve energy better than the standard implementation just by simply updating the velocity before position at every step (explicit version does the opposite).
$$v_{i+1} = v_i + a_i * \Delta t $$
$$r_{i+1} = r_{i} + v_{i+1} * \Delta t$$</p>
<p>This method is a 1st order meaning:</p>
<ul>
<li>Local error: $O(\Delta t^2)$</li>
<li>Global error:  $O(\Delta t$)</li>
</ul>
<h4 id="velocity-verlet-kdk-leapfrog">Velocity-Verlet (KDK-Leapfrog)<a hidden class="anchor" aria-hidden="true" href="#velocity-verlet-kdk-leapfrog">#</a></h4>
<p>Also known as Kick-Drift-Kick Leapfrog. This method is almost as computationally cheap as Euler, however it is a 2nd order method that also conserves energy making it more accurate. To calculate the velocity and position, simply:
$$v_{i+\frac{1}{2}} = v_i + 0.5 * a_i * \Delta t$$
$$r_{i+1} = r_i + v_{i+\frac{1}{2}} * \Delta t$$
$$a_{i+1} = \text{acceleration using the new position } r_{i+1}$$
$$v_{i+1} = v_{i+\frac{1}{2}} + 0.5 * a_i * \Delta t$$</p>
<p>This method is a 2nd order method meaning</p>
<ul>
<li>Local error: $O(\Delta t^3)$</li>
<li>Global error: $O(\Delta t^2)$</li>
</ul>
<h2 id="engine-implementation">Engine Implementation<a hidden class="anchor" aria-hidden="true" href="#engine-implementation">#</a></h2>
<p>This project features a custom-built engine that serves as the core driver for the simulation. It is designed to model and render gravitational interactions of large clusters of celestial bodies in real-time. The engine leverages GPU acceleration through custom-written compute shaders as well as implementing techniques such as instancing and post-processing to improve the visual fidelity.  The following section will explain the engine&rsquo;s architecture and other important information.</p>
<h3 id="dependencies-and-tools">Dependencies and Tools<a hidden class="anchor" aria-hidden="true" href="#dependencies-and-tools">#</a></h3>
<ul>
<li><strong>GLAD</strong> and <strong>GLFW</strong> for setting up and managing the OpenGL context</li>
<li><strong>GLM</strong> for mathematic operations.</li>
<li><strong>ImGui</strong> for the Graphical User Interface (GUI)</li>
</ul>
<h3 id="modules">Modules<a hidden class="anchor" aria-hidden="true" href="#modules">#</a></h3>
<p align="center">
    <img src="/001_N-body-simulation/ARCH.webp" loading="lazy" alt="ARCH">
    <br>
    Brief Execution Flow
    </p>
<br>
<p>The modules in this engine can be grouped into 5 parts as shown in the figure above.</p>
<ol>
<li>The Graphics Components Modules
<ul>
<li>Responsible for rendering frames to the window, managing mesh instancing, and applying post-processing effects such as bloom to enhance the visual fidelity of the simulation.</li>
</ul>
</li>
<li>The Physics Simulator Modules
<ul>
<li>Responsible for handling the calculation of the dynamical system based on the chosen implementation and integrators.</li>
</ul>
</li>
<li>The User input and display information Modules
<ul>
<li>Responsible for accepting user input from mouse control, keyboard input, and GUI toggles.</li>
<li>Updates simulation and display statuses according to the user input and show the current state of the engine to the user through GUI.</li>
</ul>
</li>
<li>The simulation initializer Modules
<ul>
<li>Responsible for taking in user input for initializing the particle data such as the geometry of the cluster, mass range, velocity range, number of particles for the simulator.</li>
</ul>
</li>
<li>The standalone program initializer Modules
<ul>
<li>Initialize OpenGL context, creating windows, and initializing required components for sphere instancing.</li>
</ul>
</li>
<li>The Enums and Structs Modules
<ul>
<li>Serves as data payload when transferring data between modules.</li>
</ul>
</li>
</ol>
<p>The Graphics and Physics Modules are designed to be independent from each other ensuring ease of modification. The User input and Display information modules however are more tightly coupled with multiple other modules due to being the interface between the users and the engine. As a result, changes in other modules would often require update in this one.</p>
<h3 id="very-brief-execution-flow-and-render-loop">Very Brief Execution flow and Render Loop<a hidden class="anchor" aria-hidden="true" href="#very-brief-execution-flow-and-render-loop">#</a></h3>
<p align="center">
    <img src="/001_N-body-simulation/program_flow.webp" loading="lazy" alt="program_flow">
    <br>
    Brief Execution Flow
    </p>
<br>
<h2 id="shader-pipeline-and-post-processing">Shader Pipeline and Post-Processing<a hidden class="anchor" aria-hidden="true" href="#shader-pipeline-and-post-processing">#</a></h2>
<p>The post-processing effect implemented for this engine is, for the moment just bloom and some color correction features.</p>
<h3 id="bloom">Bloom<a hidden class="anchor" aria-hidden="true" href="#bloom">#</a></h3>
<p align="center">
    <img src="/001_N-body-simulation/bloom_off_vs_on.webp" loading="lazy" alt="bloom_off_vs_on">
    <br>
    <i>figure 2: Bloom off vs on</i>
    </p>
<br>
<p>The idea of bloom is mostly simple. We first render the scene onto 2 separated textures. For the first texture, we keep it as the original. For the second texture, we do 2 passes gaussian blur based on the intensity we want. Afterwards we combine the two texture and do some color correction and now we have a functioning bloom output that can be used to draw on a quad.</p>
<h3 id="pipeline">Pipeline<a hidden class="anchor" aria-hidden="true" href="#pipeline">#</a></h3>
<p align="center">
    <img src="/001_N-body-simulation/rendering_pipeline.webp" loading="lazy" alt="rendering_pipeline">
    <br>
    Rendering Pipeline
    </p>
<br>
<p>In this pipeline, we can split it into 2 main paths.</p>
<ol>
<li><strong>Bloom enabled:</strong></li>
</ol>
<ul>
<li>The main idea is basically we draw to a texture as an output, afterwards we use the texture rendered as quad for the following steps.</li>
</ul>
<p>※ Do note that the $n/2$ in the image above is just a simplification</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">glFramebufferTexture2D</span><span class="p">(</span><span class="n">GL_FRAMEBUFFER</span><span class="p">,</span> <span class="n">GL_COLOR_ATTACHMENT0</span><span class="p">,</span> <span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">tex_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span></code></pre></div><ul>
<li>In this case we have to bind the render of the output to bloom shader with no Color correction (tone mapping and gamma correction) to a texture.</li>
<li>After that we use one of the textures to do 2 passes blur for a number of times.</li>
<li>After which we combines the output with the original texture then do the color correction and renders onto a quad.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">calc_gaussian_kernel</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BLUR_RADIUS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="n">sigma</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span><span class="o">/</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mf">3.141592653589793</span><span class="p">)</span><span class="o">*</span><span class="n">sigma</span><span class="p">)</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">calc_gaussian_kernel</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">vec2</span> <span class="n">tex_offset</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">textureSize</span><span class="p">(</span><span class="n">u_prev_texture</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">//size of texel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vec3</span> <span class="n">color</span> <span class="o">=</span> <span class="n">texture</span><span class="p">(</span><span class="n">u_prev_texture</span><span class="p">,</span> <span class="n">tex_coord</span><span class="p">).</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">is_horizontal</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BLUR_RADIUS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">color</span> <span class="o">+=</span> <span class="n">texture</span><span class="p">(</span><span class="n">u_prev_texture</span><span class="p">,</span> <span class="n">tex_coord</span> <span class="o">+</span> <span class="n">vec2</span><span class="p">(</span><span class="n">tex_offset</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">)).</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">color</span> <span class="o">+=</span> <span class="n">texture</span><span class="p">(</span><span class="n">u_prev_texture</span><span class="p">,</span> <span class="n">tex_coord</span> <span class="o">-</span> <span class="n">vec2</span><span class="p">(</span><span class="n">tex_offset</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">)).</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// vertical
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BLUR_RADIUS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">color</span> <span class="o">+=</span> <span class="n">texture</span><span class="p">(</span><span class="n">u_prev_texture</span><span class="p">,</span> <span class="n">tex_coord</span> <span class="o">+</span> <span class="n">vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tex_offset</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">i</span><span class="p">)).</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="n">color</span> <span class="o">+=</span> <span class="n">texture</span><span class="p">(</span><span class="n">u_prev_texture</span><span class="p">,</span> <span class="n">tex_coord</span> <span class="o">-</span> <span class="n">vec2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tex_offset</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">i</span><span class="p">)).</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">color</span><span class="p">,</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>Important Notes</strong></p>
<ul>
<li>※ Disable depth test before drawing to a quad (rectangle)</li>
<li>Ensure you bind an RBO to the original scene FBO too otherwise we will some issue with depth</li>
</ul>
<ol>
<li><strong>Bloom disabled:</strong></li>
</ol>
<ul>
<li>Directly follow the path marked in green and render the scene out with color correction.</li>
</ul>
<h3 id="hdr-exposure-tone-mapping-and-gamma-correction">HDR, Exposure Tone Mapping and Gamma Correction<a hidden class="anchor" aria-hidden="true" href="#hdr-exposure-tone-mapping-and-gamma-correction">#</a></h3>
<p>The color of the stars defined in HDR range</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="n">vec3</span> <span class="n">yellow</span> <span class="o">=</span><span class="n">vec3</span><span class="p">(</span><span class="mf">5.0f</span><span class="p">,</span> <span class="mf">2.0f</span><span class="p">,</span> <span class="mf">0.24f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span></code></pre></div><p>In this case we have to perform exposure tone-mapping to allow the brightness of scene to be displayed within range of a standard screen  [0,1]</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">	<span class="n">color</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">color</span> <span class="o">*</span> <span class="n">u_exposure</span><span class="p">);</span>
</span></span></code></pre></div><p>Afterwards, gamma correction is then applied to ensure the color to appear correctly on standard screen.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="n">color</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">u_gamma</span><span class="p">));</span>
</span></span></code></pre></div><h2 id="instancing">Instancing<a hidden class="anchor" aria-hidden="true" href="#instancing">#</a></h2>
<p>Instancing is simple, in this case we just instance all the particles as a sphere using the VAO we bind earlier and draw elements using <code>glDrawElementsInstanced</code>, on the Shader side, we just simply scale the vertices of the sphere by its mass then offset them by the position stored in the SSBO.</p>
<p align="center">
    <img src="/001_N-body-simulation/instancing_off_vs_on.webp" loading="lazy" alt="instancing_off_vs_on">
    <br>
    <i>figure 2: Instancing (+Wireframe) off vs on</i>
    </p>
<br>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// CPU side
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">use_instancing</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">shader_program</span><span class="o">-&gt;</span><span class="n">set_bool</span><span class="p">(</span><span class="s">&#34;use_instancing&#34;</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">use_instancing</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_POINTS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">simulator</span><span class="o">-&gt;</span><span class="n">get_n_particle</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">shader_program</span><span class="o">-&gt;</span><span class="n">set_bool</span><span class="p">(</span><span class="s">&#34;use_instancing&#34;</span><span class="p">,</span> <span class="o">!</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">use_instancing</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_POINTS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">simulator</span><span class="o">-&gt;</span><span class="n">get_n_particle</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">shader_program</span><span class="o">-&gt;</span><span class="n">set_bool</span><span class="p">(</span><span class="s">&#34;use_instancing&#34;</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">use_instancing</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">glDrawElementsInstanced</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">render_components</span><span class="o">-&gt;</span><span class="n">n_inds</span><span class="p">,</span> <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">simulator</span><span class="o">-&gt;</span><span class="n">get_n_particle</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">//light.vs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">layout</span> <span class="p">(</span><span class="n">std430</span><span class="p">,</span> <span class="n">binding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">buffer</span> <span class="n">particle_position</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">	<span class="n">vec4</span> <span class="n">position</span><span class="p">[];</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">//Check the full version on my repository
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span> 
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">use_instancing</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">new_pos</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="n">gl_VertexID</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">star_mass</span> <span class="o">=</span> <span class="n">mass</span><span class="p">[</span><span class="n">gl_VertexID</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">use_mass_size</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="n">mass_size</span> <span class="o">+=</span> <span class="n">calculate_mass_scaler</span><span class="p">(</span><span class="n">gl_InstanceID</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">new_pos</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="n">gl_InstanceID</span><span class="p">]</span> <span class="o">+</span> <span class="n">vec4</span><span class="p">(</span><span class="n">mass_size</span> <span class="o">*</span> <span class="n">v_pos</span><span class="p">,</span><span class="mf">1.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="n">star_mass</span> <span class="o">=</span> <span class="n">mass</span><span class="p">[</span><span class="n">gl_InstanceID</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><h3 id="why-draw-twice-when-instancing-specifically-for-our-case">Why draw twice when instancing (specifically for our case)<a hidden class="anchor" aria-hidden="true" href="#why-draw-twice-when-instancing-specifically-for-our-case">#</a></h3>
<p>Currently, we have no boundary set for our simulation meaning that once a particle moves away from the screen, it gets too tiny to get rendered onto the screen. With this issue in mind, we simply use <code>glDrawArrays(GL_POINTS...)</code> first to ensure that there will at least be something drawn to the screen at minimum size. Afterwards we draw the instanced version on top of the dot version. Doing this will ensure that for any area of the screen where the instanced particles are drawn, the point version will completely be blocked.</p>
<p align="center">
    <img src="/001_N-body-simulation/1vsdouble_draw.webp" loading="lazy" alt="1vsdouble_draw">
    <br>
    One draw call vs double draw call
    </p>
<br>
<h2 id="gpu-optimization-and-performance">GPU optimization and performance<a hidden class="anchor" aria-hidden="true" href="#gpu-optimization-and-performance">#</a></h2>
<h3 id="performance">Performance<a hidden class="anchor" aria-hidden="true" href="#performance">#</a></h3>
<p>Due to time constraint, I have yet to make proper benchmarking scripts or setting up Nsight for performance profiling. The performance was recorded manually and averaged on the hardware this simulation was implemented in (RTX4070Ti GPU).</p>
<p>The FPS are written in format &lt;Effects ON - Effects OFF&gt;. These numbers should give a rough idea on how it should perform given this specific hardware.</p>
<table>
  <thead>
      <tr>
          <th># Particles / Implementation (FPS)</th>
          <th>CPU Naive Particle-Particle</th>
          <th>GPU Naive Particle-Particle</th>
          <th>GPU Tiling Particle-Particle</th>
          <th>GPU Fine-Grain Particle-Particle</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>n = 100</td>
          <td>120</td>
          <td>120</td>
          <td>120</td>
          <td>120</td>
      </tr>
      <tr>
          <td>n = 1000</td>
          <td>90-91</td>
          <td>120</td>
          <td>120</td>
          <td>120</td>
      </tr>
      <tr>
          <td>n = 10000</td>
          <td>1</td>
          <td>120</td>
          <td>120</td>
          <td>120</td>
      </tr>
      <tr>
          <td>n = 30000</td>
          <td>-</td>
          <td>120</td>
          <td>120</td>
          <td>120</td>
      </tr>
      <tr>
          <td>n = 50000</td>
          <td>-</td>
          <td>88 ~ 100</td>
          <td>117 ~ 120</td>
          <td>109 ~ 120</td>
      </tr>
      <tr>
          <td>n = 65000</td>
          <td>-</td>
          <td>57 ~ 63</td>
          <td>66 ~ 74</td>
          <td>68  ~ 75</td>
      </tr>
      <tr>
          <td>n = 100000</td>
          <td>-</td>
          <td>23 ~ 23</td>
          <td>37 ~ 40</td>
          <td>30 ~ 32</td>
      </tr>
      <tr>
          <td>n = 150000</td>
          <td>-</td>
          <td>12 ~ 12</td>
          <td>17 ~ 18</td>
          <td>14 ~ 14</td>
      </tr>
      <tr>
          <td>n = 200000</td>
          <td>-</td>
          <td>7 ~ 7</td>
          <td>8 ~ 8</td>
          <td>8 ~ 8</td>
      </tr>
  </tbody>
</table>
<h3 id="naive-gpu-implementation">Naive GPU Implementation<a hidden class="anchor" aria-hidden="true" href="#naive-gpu-implementation">#</a></h3>
<p>The naive implementation uses 1 workgroup per 64 particle. The idea is basically using velocity-verlet integrator to calculate the next step without further optimization.</p>
<p>This version does introduce some inaccuracies as well (I have yet to fix this). This is due to the fact that barrier only blocks the threads in the same workgroup, not globally, meaning that there can be some case of race conditions where position is used to calculate acceleration before some is updated.</p>
<ul>
<li>Work: $O(n^2)$</li>
<li>Span: $O(n)$</li>
<li>Available Parallelism: $O(n)$</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">	<span class="n">uint</span> <span class="n">id</span> <span class="o">=</span> <span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">n_particle</span><span class="p">)</span> <span class="k">return</span> <span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">velocity</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">+=</span> <span class="n">acceleration</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">*</span> <span class="n">timestep_size</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">position</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">+=</span> <span class="n">velocity</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">*</span> <span class="n">timestep_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">memoryBarrier</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">barrier</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">acceleration</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">calculate_acceleration</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="o">*</span> <span class="n">gravitational_constant</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">memoryBarrier</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">barrier</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">velocity</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">+=</span> <span class="n">acceleration</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">*</span> <span class="n">timestep_size</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span> 
</span></span></code></pre></div><h3 id="tiling---chunk-optimized-gpu-implementation">Tiling - Chunk Optimized GPU Implementation<a hidden class="anchor" aria-hidden="true" href="#tiling---chunk-optimized-gpu-implementation">#</a></h3>
<p>In this implementation, the idea of tiling in chunks into the shared memory has been introduced. Since fetching data repeatedly from global memory is an expensive operation. Having multiple threads in the same group collectively fetch a chunk of data into shared memory where the threads inside the same workgroup can access to calculate acceleration. This approach is likely a better approach since it reduces the amount of fetching needed to be done from global memory. This version is implemented in 2 passes.</p>
<p>In my case, a chunk-size of 512 and a workgroup of size x=256 seems to be the best performing settings.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">CHUNK_SIZE</span> <span class="o">=</span> <span class="mi">512</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">shared</span> <span class="n">vec4</span> <span class="n">chunk_position</span><span class="p">[</span><span class="n">CHUNK_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">shared</span> <span class="kt">float</span> <span class="n">chunk_mass</span><span class="p">[</span><span class="n">CHUNK_SIZE</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">main</span><span class="p">(){....</span>
</span></span><span class="line"><span class="cl"><span class="n">uint</span> <span class="n">particle_id</span> <span class="o">=</span> <span class="n">gl_GlobalInvocationID</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="n">uint</span> <span class="n">local_id</span> <span class="o">=</span> <span class="n">gl_LocalInvocationID</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span></code></pre></div><ul>
<li>Work: $O(n^2)$</li>
<li>Span: $O(n)$</li>
<li>Available Parallelism: $O(n)$</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Pre-load position of current particle if valid
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">vec4</span> <span class="n">position_self</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">particle_id</span> <span class="o">&lt;</span> <span class="n">n_particle</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">position_self</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="n">particle_id</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">max_load</span> <span class="o">=</span> <span class="n">CHUNK_SIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">half_chunk</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">fetch_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">n_particle</span> <span class="o">+</span> <span class="n">CHUNK_SIZE</span><span class="p">);</span> <span class="n">offset</span><span class="o">+=</span><span class="n">CHUNK_SIZE</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Load chunk
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">chunk_mass</span><span class="p">[</span><span class="n">local_id</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">mass</span><span class="p">[</span><span class="n">local_id</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="n">offset</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">chunk_position</span><span class="p">[</span><span class="n">local_id</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="n">local_id</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="n">offset</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">chunk_mass</span><span class="p">[</span><span class="n">local_id</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mass</span><span class="p">[</span><span class="n">local_id</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="n">offset</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">chunk_position</span><span class="p">[</span><span class="n">local_id</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="n">local_id</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">+</span> <span class="n">offset</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">memoryBarrier</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">barrier</span><span class="p">();</span>
</span></span></code></pre></div><p>Here, each thread each load 2 pieces of data into shared memory per loop.
From here calculation of acceleration is done as usual.</p>
<h3 id="fine-grained-gpu-implementation">Fine-Grained GPU Implementation<a hidden class="anchor" aria-hidden="true" href="#fine-grained-gpu-implementation">#</a></h3>
<p>In this implementation, instead of using multiple particles per workgroup. I have decided to use 1 particle per work group. However, the amount work is equally distributed among threads.</p>
<p>In the first pass, we use the standard 256 particle per thread implementation to update the position and velocity.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">this</span><span class="o">-&gt;</span><span class="n">compute_shader_program</span><span class="p">.</span><span class="n">set_bool</span><span class="p">(</span><span class="s">&#34;first_pass&#34;</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">glDispatchCompute</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">n_work_groups</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">glMemoryBarrier</span><span class="p">(</span><span class="n">GL_SHADER_STORAGE_BARRIER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">this</span><span class="o">-&gt;</span><span class="n">compute_shader_program</span><span class="p">.</span><span class="n">set_bool</span><span class="p">(</span><span class="s">&#34;first_pass&#34;</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">glDispatchCompute</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">n_particle</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span></code></pre></div><p>Afterwards, for the second pass, we have shared variable setup for accumulation.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">shared</span> <span class="n">vec4</span> <span class="n">local_acceleration_accumulator</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">uint</span> <span class="n">particle_id</span> <span class="o">=</span> <span class="n">gl_WorkGroupID</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>   
</span></span><span class="line"><span class="cl"><span class="n">uint</span> <span class="n">local_id</span> <span class="o">=</span> <span class="n">gl_LocalInvocationID</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span></span></code></pre></div><p>The acceleration calculation is then done by having each thread accumulate the acceleration based on their local id (workgroup ID ) then add this to the shared memory before proceeding to the next stage.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="n">local_id</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">uint</span><span class="p">(</span><span class="n">n_particle</span><span class="p">);</span> <span class="n">i</span><span class="o">+=</span> <span class="mi">256</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">tmp_distance</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="n">particle_id</span><span class="p">]</span> <span class="o">-</span> <span class="n">position</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">tmp_distance</span> <span class="o">!=</span> <span class="n">vec4</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">            <span class="n">tmp_direction</span> <span class="o">=</span> <span class="o">-</span><span class="n">normalize</span><span class="p">(</span><span class="n">tmp_distance</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">sq_distance</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">tmp_distance</span><span class="p">,</span><span class="n">tmp_distance</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">local_acceleration_sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">mass</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sq_distance</span><span class="o">+</span><span class="n">sq_soften</span><span class="p">))</span> <span class="o">*</span> <span class="n">tmp_direction</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">local_acceleration_accumulator</span><span class="p">[</span><span class="n">local_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_acceleration_sum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">barrier</span><span class="p">();</span>
</span></span></code></pre></div><p>After accumulating all the acceleration locally, we then accumulate the acceleration using tree based reduction until acceleration at local_id 0 have the sum of all acceleration.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">stride</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span> <span class="n">stride</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">stride</span> <span class="o">&gt;&gt;=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">local_id</span> <span class="o">&lt;</span> <span class="n">stride</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">local_acceleration_accumulator</span><span class="p">[</span><span class="n">local_id</span><span class="p">]</span> <span class="o">+=</span> <span class="n">local_acceleration_accumulator</span><span class="p">[</span><span class="n">local_id</span> <span class="o">+</span> <span class="n">stride</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">barrier</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>Afterwards we calculate the velocity as usual.</p>
<ul>
<li>Work: $O(n^2)$</li>
<li>Span: $O(n)$</li>
<li>Available Parallelism: $O(n)$</li>
</ul>
<h3 id="2-passes-and-global-synchronization">2 Passes and Global Synchronization<a hidden class="anchor" aria-hidden="true" href="#2-passes-and-global-synchronization">#</a></h3>
<p>Since the order of computation of velocity-verlet is</p>
<ol>
<li>Calculate half velocity</li>
<li>Calculate new position</li>
<li>Calculate acceleration</li>
<li>Calculate half velocity</li>
</ol>
<p>Between step 2 and 3, if some workgroup finishes faster than the other, we might have issue where the acceleration is calculated using the position other variables of the previous step creating minor accuracies that accumulate overtime.</p>
<p>To counter this issue, one way is to use 2 compute dispatch separated by global memory barrier.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">compute_shader_program</span><span class="p">.</span><span class="n">set_bool</span><span class="p">(</span><span class="s">&#34;first_pass&#34;</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">glDispatchCompute</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">n_work_groups</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">glMemoryBarrier</span><span class="p">(</span><span class="n">GL_SHADER_STORAGE_BARRIER_BIT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">compute_shader_program</span><span class="p">.</span><span class="n">set_bool</span><span class="p">(</span><span class="s">&#34;first_pass&#34;</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">glDispatchCompute</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">n_work_groups</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span></code></pre></div><p>something like this, to ensure that the value syncs before we update the next step.</p>
<h2 id="future-improvements">Future Improvements<a hidden class="anchor" aria-hidden="true" href="#future-improvements">#</a></h2>
<ul>
<li>Further optimization on the particle interaction calculations (use oct-tree, FMM, Barnes-Hut&hellip;)</li>
<li>More effects?</li>
<li>Save-Load system</li>
</ul>
<h3 id="known-issues">Known Issues<a hidden class="anchor" aria-hidden="true" href="#known-issues">#</a></h3>
<ul>
<li>If you set the velocity or mass to some crazy stuffs and you start to see some void ball in the middle of your screen, fear not for the stuffs is actually flying off the camera limit&hellip; 😂 [Will need to set world boundary probably]</li>
<li>The sphere is sampled using <code>glm::sphericalRand</code> so there is a gaping hole and a line on some position&hellip;</li>
<li>Particle-Particle NAIVE GPU have very minor inaccuracy issue due to being done in 1 pass</li>
</ul>
<h2 id="references-and-resources">References and Resources<a hidden class="anchor" aria-hidden="true" href="#references-and-resources">#</a></h2>
<p>Here are list of resources I read while researching on how to build this simulator, you will probably find them useful if you want to dive deeper into this subject!</p>
<ul>
<li><a href="https://learnopengl.com/">https://learnopengl.com/</a></li>
<li><a href="https://www.youtube.com/@OnurMutluLectures">https://www.youtube.com/@OnurMutluLectures</a></li>
<li><a href="https://en.wikipedia.org/wiki/n-body">https://en.wikipedia.org/wiki/n-body</a> problem. (n.d.).</li>
<li><a href="https://en.wikipedia.org/wiki/Leapfrog_integration">https://en.wikipedia.org/wiki/Leapfrog_integration</a></li>
<li>Dehnen, W., &amp; Read, J. (2011). N-body simulations of gravitational dynamics. arxiv:1105.1082v1.</li>
<li>Brandt, A. (2022, 03). On distributed gravitational n-body simulations, arxiv:2203.08966. <a href="https://arxiv.org/pdf/2203.08966">https://arxiv.org/pdf/2203.08966</a></li>
<li>Computation and astrophysics of the n-body problem. (n.d.). Graps, A. (1996). N-body / particle simulation methods. <a href="https://www.cs.cmu.edu/afs/cs/academic/class/15850c-s96/www/nbody.html">https://www.cs.cmu.edu/afs/cs/academic/class/15850c-s96/www/nbody.html</a></li>
<li><a href="https://www.algorithm-archive.org/contents/verlet_integration/verlet_integration.html">https://www.algorithm-archive.org/contents/verlet_integration/verlet_integration.html</a></li>
<li><a href="https://developer.nvidia.com/gpugems/gpugems/part-vi-beyond-triangles/chapter-37-toolkit-computation-gpus">https://developer.nvidia.com/gpugems/gpugems/part-vi-beyond-triangles/chapter-37-toolkit-computation-gpus</a></li>
<li><a href="https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation/chapter-31-fast-n-body-simulation-cuda">https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation/chapter-31-fast-n-body-simulation-cuda</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://maythaswang.github.io/ja/tags/opengl/">OpenGL</a></li>
      <li><a href="https://maythaswang.github.io/ja/tags/realtime/">RealTime</a></li>
      <li><a href="https://maythaswang.github.io/ja/tags/compute-shaders/">Compute Shaders</a></li>
      <li><a href="https://maythaswang.github.io/ja/tags/particle-system/">Particle System</a></li>
      <li><a href="https://maythaswang.github.io/ja/tags/post-processing/">Post-Processing</a></li>
      <li><a href="https://maythaswang.github.io/ja/tags/optimization/">Optimization</a></li>
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 宇宙のシミュレーション - N体シミュレーション on x"
            href="https://x.com/intent/tweet/?text=%e5%ae%87%e5%ae%99%e3%81%ae%e3%82%b7%e3%83%9f%e3%83%a5%e3%83%ac%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%20-%20N%e4%bd%93%e3%82%b7%e3%83%9f%e3%83%a5%e3%83%ac%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3&amp;url=https%3a%2f%2fmaythaswang.github.io%2fja%2fposts%2f001_n-body-simulation%2f&amp;hashtags=OpenGL%2cRealTime%2cComputeShaders%2cParticleSystem%2cPost-Processing%2cOptimization">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 宇宙のシミュレーション - N体シミュレーション on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fmaythaswang.github.io%2fja%2fposts%2f001_n-body-simulation%2f&amp;title=%e5%ae%87%e5%ae%99%e3%81%ae%e3%82%b7%e3%83%9f%e3%83%a5%e3%83%ac%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%20-%20N%e4%bd%93%e3%82%b7%e3%83%9f%e3%83%a5%e3%83%ac%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3&amp;summary=%e5%ae%87%e5%ae%99%e3%81%ae%e3%82%b7%e3%83%9f%e3%83%a5%e3%83%ac%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%20-%20N%e4%bd%93%e3%82%b7%e3%83%9f%e3%83%a5%e3%83%ac%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3&amp;source=https%3a%2f%2fmaythaswang.github.io%2fja%2fposts%2f001_n-body-simulation%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 宇宙のシミュレーション - N体シミュレーション on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fmaythaswang.github.io%2fja%2fposts%2f001_n-body-simulation%2f&title=%e5%ae%87%e5%ae%99%e3%81%ae%e3%82%b7%e3%83%9f%e3%83%a5%e3%83%ac%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%20-%20N%e4%bd%93%e3%82%b7%e3%83%9f%e3%83%a5%e3%83%ac%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 宇宙のシミュレーション - N体シミュレーション on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmaythaswang.github.io%2fja%2fposts%2f001_n-body-simulation%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 宇宙のシミュレーション - N体シミュレーション on whatsapp"
            href="https://api.whatsapp.com/send?text=%e5%ae%87%e5%ae%99%e3%81%ae%e3%82%b7%e3%83%9f%e3%83%a5%e3%83%ac%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%20-%20N%e4%bd%93%e3%82%b7%e3%83%9f%e3%83%a5%e3%83%ac%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%20-%20https%3a%2f%2fmaythaswang.github.io%2fja%2fposts%2f001_n-body-simulation%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 宇宙のシミュレーション - N体シミュレーション on telegram"
            href="https://telegram.me/share/url?text=%e5%ae%87%e5%ae%99%e3%81%ae%e3%82%b7%e3%83%9f%e3%83%a5%e3%83%ac%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%20-%20N%e4%bd%93%e3%82%b7%e3%83%9f%e3%83%a5%e3%83%ac%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3&amp;url=https%3a%2f%2fmaythaswang.github.io%2fja%2fposts%2f001_n-body-simulation%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 宇宙のシミュレーション - N体シミュレーション on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=%e5%ae%87%e5%ae%99%e3%81%ae%e3%82%b7%e3%83%9f%e3%83%a5%e3%83%ac%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%20-%20N%e4%bd%93%e3%82%b7%e3%83%9f%e3%83%a5%e3%83%ac%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3&u=https%3a%2f%2fmaythaswang.github.io%2fja%2fposts%2f001_n-body-simulation%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://maythaswang.github.io/ja/">Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
